#' @title Build project to output
#'
#' @description Builds project to output, which
#' means recording the input and output data hashes,
#' building the actual bookdown document and
#' saving and archiving selected output.
#'
#' @param bump_component "major", "minor", "patch" or missing.
#' Specifies version component to increment.
#' If missing, then is set equal to the lowest version component
#' in used version format.
#' No default (i.e. is missing by default).
#' @param msg character.
#' Message to append to Git commit messages.
#' Default is \code{NULL}, in which
#' case the user is prompted for a message or,
#' if the session is not interactive, it is
#' left empty.
#' Default is \code{NULL}.
#' Note that the Git messages in this case would not be blank -
#' they would simply consist of details as to the version
#' being bumped to and the stage in the build process
#' at which the commit was made.
#'
#' @param ... Arguments passed to \code{bookdown::render}.
#'
#' @export
projr_build_output <- function(bump_component, msg = NULL, ...) {
  if (missing(bump_component)) {
    yml_projr <- projr_yml_get()
    version <- yml_projr[["version-format"]]
    version_vec <- strsplit(version, split = "\\.|\\-")[[1]]
    bump_component <- version_vec[length(version_vec) - 1]
  }
  if (is.null(msg)) {
    if (!Sys.getenv("PROJR_TEST") == "TRUE") {
      if (interactive()) {
        cat("Please enter a one-line description of change", "\n")
        msg <- readline(prompt = ">> ")
      } else {
        msg <- ""
      }
    } else {
      msg <- ""
    }
  }
  .projr_build(bump_component = bump_component, msg = msg, ...)
}

#' @title Build dev project
#'
#' @description Builds project to output, which
#' means recording the input and output data hashes,
#' building the actual bookdown document and
#' saving and archiving selected output.
#'
#' @param bump logical.
#' Whether to increment dev version for build.
#' Default is \code{FALSE}.
#' @param ... Arguments passed to \code{bookdown::render}.
#'
#' @export
projr_build_dev <- function(bump = FALSE, ...) {
  # NULL if FALSE and "dev" if TRUE
  bump_component <- switch(bump,
    "dev"
  )
  .projr_build(bump_component = bump_component, ...)
}

.projr_build <- function(bump_component, msg = "", ...) {
  # ========================
  # SET-UP
  # ========================

  # whether it's an output run  or not
  output_run <- !(is.null(bump_component) || bump_component == "dev")

  # get version for DESCRIPTION and bookdown from run onwards
  # snapshot if need be
  .projr_build_renv_snapshot(output_run)

  # make sure everything is ignored that should be ignored
  .projr_build_ignore()

  # set the output directory to that in "_projr.yml"
  .projr_build_doc_output_dir_update()

  # get DESCRIPTION and build versions under all
  # build outcomes
  version_run_on_list <- .projr_version_run_onwards_get(
    bump_component = bump_component
  )

  # commit any unstaged files pre-run
  .projr_build_git_commit(
    output_run = output_run,
    bump_component = bump_component,
    version_run_on_list = version_run_on_list,
    stage = "pre",
    msg = msg
  )

  # set the version pre-run
  .projr_build_version_set_pre(version_run_on_list)

  # empty output directories
  # (bookdown, output and data)
  .projr_build_clear_pre(output_run)

  # hash cache
  manifest_tbl_pre <- .projr_build_manifest_hash_pre()

  # ========================
  # RUN
  # ========================

  .projr_build_engine(version_run_on_list, ...)

  # ========================
  # HANDLE OUTPUTS
  # ========================

  # get version for DESCRIPTION and bookdown from run onwards

  # update lock file, help files and README
  .projr_build_renv_snapshot(output_run)
  .projr_build_roxygenise(output_run)
  .projr_build_readme_rmd_render(output_run)

  # hash data-raw and outputs
  manifest_tbl <- manifest_tbl_pre |>
    rbind(.projr_build_manifest_hash_post())

  # remove dev output files
  .projr_build_clear_post(output_run)

  # copy outputs to (final) output directory and archive
  .projr_build_copy(output_run, bump_component, version_run_on_list)

  # commit any files generated by run
  .projr_build_git_commit(
    output_run = output_run,
    bump_component = bump_component,
    version_run_on_list = version_run_on_list,
    stage = "post",
    msg = msg
  )

  # save manifest table
  .projr_build_manifest_save(manifest_tbl)

  # upload via piggyback
  .projr_pb_upload(
    output_run = output_run
  )

  # initate dev version
  # ------------------

  # set version
  .projr_build_version_set_post(
    version_run_on_list = version_run_on_list,
    success = TRUE
  )

  # commit dev version
  .projr_build_git_commit(
    output_run = output_run,
    bump_component = bump_component,
    version_run_on_list = version_run_on_list,
    stage = "dev",
    msg = msg
  )

  # push
  # --------------------

  # push to GitHub
  .projr_build_git_push()

  invisible(TRUE)
}

.projr_build_engine <- function(version_run_on_list, ...) {
  build_status <- switch(.projr_engine_get(),
    "bookdown" = try(bookdown::render_book(...)),
    "quarto_project" = try(quarto::quarto_render(...)),
    "quarto_document" = {
      try(
        for (x in list.files(pattern = "\\.qmd$")) {
          quarto::quarto_render(x, ...)
        }
      )
    },
    "rmd" = {
      try(
        for (x in list.files(pattern = "\\.Rmd$|\\.rmd$")) {
          rmarkdown::render(x, ...)
        }
      )
    }
  )

  if (identical(class(build_status), "try-error")) {
    .projr_build_version_set_post(
      version_run_on_list = version_run_on_list,
      success = FALSE
    )
    # TODO: #156 delet
    stop(build_status)
  }
  invisible(TRUE)
}
