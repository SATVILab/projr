<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Design • projr</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Design">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">projr</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.3.3-0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/get-started.html">Get started</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/how-to-guides.html">How-to guides</a></li>
    <li><a class="dropdown-item" href="../articles/build-process.html">Build Process</a></li>
    <li><a class="dropdown-item" href="../articles/send-to-remotes.html">Sending to Remotes</a></li>
    <li><a class="dropdown-item" href="../articles/dest-send-workflow.html">Destination Send Workflow</a></li>
    <li><a class="dropdown-item" href="../articles/restore-artifacts.html">Restoring Artifacts</a></li>
    <li><a class="dropdown-item" href="../articles/environment.html">Environment Variables</a></li>
    <li><a class="dropdown-item" href="../articles/scripts-and-hooks.html">Scripts and Hooks</a></li>
    <li><a class="dropdown-item" href="../articles/concepts.html">Concepts</a></li>
    <li><a class="dropdown-item" href="../articles/design.html">Design</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-news" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">News</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-news">
<li><a class="dropdown-item" href="../news/index.html">Changelog</a></li>
    <li><a class="dropdown-item" href="../BUILDLOG.html">Build log</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/SATVILab/projr" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Design</h1>
            
      

      <div class="d-none name"><code>design.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="design-philosophy">Design philosophy<a class="anchor" aria-label="anchor" href="#design-philosophy"></a>
</h2>
<p>This article explains the design decisions behind projr and why it
works the way it does.</p>
<hr>
<div class="section level3">
<h3 id="design-goals">Design goals<a class="anchor" aria-label="anchor" href="#design-goals"></a>
</h3>
<div class="section level4">
<h4 id="minimal-cognitive-overhead">1. Minimal cognitive overhead<a class="anchor" aria-label="anchor" href="#minimal-cognitive-overhead"></a>
</h4>
<p><strong>Goal</strong>: Reduce the mental burden of maintaining
reproducible research.</p>
<p><strong>How projr achieves this:</strong></p>
<ul>
<li>
<strong>One function to remember</strong>:
<code><a href="../reference/projr_build.html">projr_build()</a></code> does everything</li>
<li>
<strong>Sensible defaults</strong>: Most projects work
out-of-the-box</li>
<li>
<strong>Convention over configuration</strong>: Standard directory
structure</li>
<li>
<strong>Gradual complexity</strong>: Start simple, customise as
needed</li>
</ul>
<p><strong>Anti-pattern</strong>: Complex build systems requiring
extensive configuration, multiple commands, and deep understanding of
internals.</p>
<p><strong>Example</strong>: Compare a typical <code>make</code>-based
workflow:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># Traditional approach</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">make</span> clean</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">make</span> data</span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="fu">make</span> analysis</span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="fu">make</span> figures</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="fu">make</span> paper</span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="fu">make</span> deploy-to-osf</span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="fu">git</span> add .</span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="fu">git</span> commit <span class="at">-m</span> <span class="st">"Update"</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="fu">git</span> push</span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="ex">gh</span> release create v0.1.0</span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co"># ... upload files manually ...</span></span></code></pre></div>
<p>With projr:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/projr_build.html">projr_build</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># That's it</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="fail-safe-iteration">2. Fail-safe iteration<a class="anchor" aria-label="anchor" href="#fail-safe-iteration"></a>
</h4>
<p><strong>Goal</strong>: Make it safe to experiment without losing
work.</p>
<p><strong>How projr achieves this:</strong></p>
<ul>
<li>
<strong>Dev builds</strong>: Route outputs to cache, never touch
<code>_output</code>
</li>
<li>
<strong>Manifests</strong>: Always know what inputs created what
outputs</li>
<li>
<strong>Git integration</strong>: Automatic commits preserve
history</li>
<li>
<strong>Reversible versioning</strong>: Can always access previous
versions via Git + archives</li>
</ul>
<p><strong>Anti-pattern</strong>: In-place modification of output
directories leading to lost results.</p>
<p><strong>Example</strong>: Without projr, you might:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Accidentally overwrite yesterday's figures</span></span>
<span><span class="fu">render</span><span class="op">(</span><span class="st">"analysis.Rmd"</span><span class="op">)</span>  <span class="co"># Oh no, the new plot is worse!</span></span>
<span><span class="co"># Now you've lost the good version</span></span></code></pre></div>
<p>With projr:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Safe iteration</span></span>
<span><span class="fu"><a href="../reference/projr_build_dev.html">projr_build_dev</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># Outputs to _tmp/</span></span>
<span><span class="co"># Check results, if bad, just run again</span></span>
<span><span class="co"># If good:</span></span>
<span><span class="fu"><a href="../reference/projr_build.html">projr_build</a></span><span class="op">(</span><span class="op">)</span>  <span class="co"># Now commit to _output</span></span></code></pre></div>
</div>
<div class="section level4">
<h4 id="automation-without-magic">3. Automation without magic<a class="anchor" aria-label="anchor" href="#automation-without-magic"></a>
</h4>
<p><strong>Goal</strong>: Automate tedious tasks whilst maintaining
transparency.</p>
<p><strong>How projr achieves this:</strong></p>
<ul>
<li>
<strong>Explicit configuration</strong>: <code>_projr.yml</code>
makes everything visible</li>
<li>
<strong>Predictable behaviour</strong>: Same inputs → same
outputs</li>
<li>
<strong>Inspectable artefacts</strong>: Manifests, build logs, Git
history</li>
<li>
<strong>No hidden state</strong>: All configuration in
version-controlled files</li>
</ul>
<p><strong>Anti-pattern</strong>: Build systems with hidden state,
implicit dependencies, or configuration scattered across multiple
locations.</p>
<p><strong>Example</strong>: projr’s manifest system:</p>
<pre class="csv"><code>label,path,hash,version,timestamp
raw-data,_raw_data,abc123...,v0.1.0,2024-01-15</code></pre>
<p>You can inspect, version-control, and audit this. Compare to a system
that tracks dependencies in a binary database or in-memory cache.</p>
</div>
<div class="section level4">
<h4 id="reproducibility-by-default">4. Reproducibility by default<a class="anchor" aria-label="anchor" href="#reproducibility-by-default"></a>
</h4>
<p><strong>Goal</strong>: Make it easier to be reproducible than
not.</p>
<p><strong>How projr achieves this:</strong></p>
<ul>
<li>
<strong>Automatic versioning</strong>: Every build is versioned</li>
<li>
<strong>Manifests</strong>: Inputs-outputs linkage is automatic</li>
<li>
<strong>renv integration</strong>: Optional package version
locking</li>
<li>
<strong>Archiving</strong>: Automatic upload to GitHub/OSF</li>
<li>
<strong>Restoration</strong>: One command to reconstruct</li>
</ul>
<p><strong>Anti-pattern</strong>: Reproducibility as an afterthought
requiring manual effort.</p>
<p><strong>Example</strong>: Without thinking about it, projr users
get:</p>
<pre><code>v0.1.0:
  - code: Git SHA abc123
  - data: Hash def456
  - outputs: Hash ghi789
  - packages: renv.lock
  - archived: GitHub Release v0.1.0</code></pre>
<p>All automatically. To reproduce:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/projr_restore.html">projr_restore_repo</a></span><span class="op">(</span><span class="st">"owner/repo"</span><span class="op">)</span></span>
<span><span class="fu">renv</span><span class="fu">::</span><span class="fu"><a href="https://rstudio.github.io/renv/reference/restore.html" class="external-link">restore</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="../reference/projr_build.html">projr_build</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="core-design-principles">Core design principles<a class="anchor" aria-label="anchor" href="#core-design-principles"></a>
</h3>
<div class="section level4">
<h4 id="single-purpose-directories">Single-purpose directories<a class="anchor" aria-label="anchor" href="#single-purpose-directories"></a>
</h4>
<p><strong>Principle</strong>: Each directory has exactly one
purpose.</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Clarity</strong>: No ambiguity about where things go</li>
<li>
<strong>Selective sharing</strong>: Archive only what’s needed</li>
<li>
<strong>Automation</strong>: Tools can act on directories knowing
their contents</li>
<li>
<strong>Restoration</strong>: Simple mapping from label to path</li>
</ul>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>✅ Structure is immediately obvious</li>
<li>✅ Easy to share/archive specific parts</li>
<li>❌ More directories than minimal structure</li>
<li>❌ Some redundancy (e.g., separate output-figures and
output-tables)</li>
</ul>
<p><strong>Why this trade-off is worth it</strong>:</p>
<p>The clarity and automation benefits outweigh the slight increase in
directory count. Modern file systems handle many directories
efficiently.</p>
</div>
<div class="section level4">
<h4 id="versioned-builds-not-versioned-files">Versioned builds, not versioned files<a class="anchor" aria-label="anchor" href="#versioned-builds-not-versioned-files"></a>
</h4>
<p><strong>Principle</strong>: Version the entire project state, not
individual files.</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Coherence</strong>: All files at version X are consistent
with each other</li>
<li>
<strong>Simplicity</strong>: One version number, not per-file
versions</li>
<li>
<strong>Traceability</strong>: Know exactly what produced what</li>
<li>
<strong>Restoration</strong>: Restore entire consistent state</li>
</ul>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>✅ Simpler mental model (one version)</li>
<li>✅ Guarantees consistency</li>
<li>❌ Version bumps even for small changes</li>
<li>❌ Can’t mix versions of different components</li>
</ul>
<p><strong>Why this trade-off is worth it</strong>:</p>
<p>Scientific outputs depend on multiple inputs. Versioning the whole
project ensures you can always reconstruct a consistent state. Per-file
versioning leads to combinatorial explosion of possible states.</p>
</div>
<div class="section level4">
<h4 id="configuration-in-yaml-not-code">Configuration in YAML, not code<a class="anchor" aria-label="anchor" href="#configuration-in-yaml-not-code"></a>
</h4>
<p><strong>Principle</strong>: Project structure and build behaviour in
<code>_projr.yml</code>, not scattered across code.</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Centralised</strong>: One place to understand project
configuration</li>
<li>
<strong>Readable</strong>: YAML is human-readable</li>
<li>
<strong>Version-controlled</strong>: Configuration changes are
tracked</li>
<li>
<strong>Shareable</strong>: Easy to share configuration across
projects</li>
</ul>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>✅ Configuration is explicit and visible</li>
<li>✅ Easy to diff and merge configuration changes</li>
<li>❌ Less flexible than code-based configuration</li>
<li>❌ YAML syntax can be tricky</li>
</ul>
<p><strong>Why this trade-off is worth it</strong>:</p>
<p>Most research projects don’t need the flexibility of code-based
configuration. The benefits of having a single, readable,
version-controlled configuration file outweigh the limitations.</p>
</div>
<div class="section level4">
<h4 id="dev-builds-vs-final-builds">Dev builds vs final builds<a class="anchor" aria-label="anchor" href="#dev-builds-vs-final-builds"></a>
</h4>
<p><strong>Principle</strong>: Separate safe iteration from committed
releases.</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Safety</strong>: Dev builds can’t accidentally overwrite
released outputs</li>
<li>
<strong>Speed</strong>: Dev builds skip versioning and
archiving</li>
<li>
<strong>Clarity</strong>: Explicit distinction between “testing” and
“committing”</li>
</ul>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>✅ Safe experimentation</li>
<li>✅ Fast feedback loop</li>
<li>❌ Two commands to remember (dev vs final)</li>
<li>❌ Cache directory can grow large</li>
</ul>
<p><strong>Why this trade-off is worth it</strong>:</p>
<p>The safety and speed benefits are critical for iterative research.
The cost of remembering two commands is minimal.</p>
</div>
<div class="section level4">
<h4 id="git-integration-not-git-dependency">Git integration, not Git dependency<a class="anchor" aria-label="anchor" href="#git-integration-not-git-dependency"></a>
</h4>
<p><strong>Principle</strong>: projr works with or without Git, but
works better with it.</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Accessibility</strong>: Beginners can use projr without
learning Git</li>
<li>
<strong>Power</strong>: Advanced users get automatic Git
integration</li>
<li>
<strong>Flexibility</strong>: Use Git features without learning
them</li>
</ul>
<p><strong>Trade-offs</strong>:</p>
<ul>
<li>✅ Low barrier to entry</li>
<li>✅ Automatic Git for those who want it</li>
<li>❌ More complex codebase (supporting both paths)</li>
<li>❌ Some features require Git (versioning)</li>
</ul>
<p><strong>Why this trade-off is worth it</strong>:</p>
<p>Git is powerful but intimidating. By making it optional, projr
reaches more users whilst still offering Git benefits to those who want
them.</p>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="architecture">Architecture<a class="anchor" aria-label="anchor" href="#architecture"></a>
</h3>
<div class="section level4">
<h4 id="layered-design">Layered design<a class="anchor" aria-label="anchor" href="#layered-design"></a>
</h4>
<p>projr is organised into layers:</p>
<pre><code>User-facing API (projr_build, projr_init, ...)
         ↓
Configuration layer (YAML parsing, validation)
         ↓
Build engine (rendering, versioning, archiving)
         ↓
Backend services (Git, GitHub, OSF, file system)</code></pre>
<p><strong>Benefits</strong>:</p>
<ul>
<li>
<strong>Modularity</strong>: Each layer can be tested
independently</li>
<li>
<strong>Extensibility</strong>: New backends (e.g., Zenodo) can be
added</li>
<li>
<strong>Clarity</strong>: Separation of concerns</li>
</ul>
</div>
<div class="section level4">
<h4 id="function-naming-conventions">Function naming conventions<a class="anchor" aria-label="anchor" href="#function-naming-conventions"></a>
</h4>
<p>projr uses systematic naming:</p>
<ul>
<li>
<code>projr_*</code> - All exported functions</li>
<li>
<code>.projr_*</code> - Internal functions (not exported)</li>
<li>
<code>projr_build*</code> - Build-related functions</li>
<li>
<code>projr_init*</code> - Initialisation functions</li>
<li>
<code>projr_yml_*</code> - YAML configuration functions</li>
<li>
<code>projr_path_*</code> - Path helper functions</li>
</ul>
<p><strong>Benefits</strong>:</p>
<ul>
<li>
<strong>Discoverability</strong>: Autocomplete groups related
functions</li>
<li>
<strong>Clarity</strong>: Function purpose is obvious from name</li>
<li>
<strong>Namespace</strong>: All public functions prefixed to avoid
conflicts</li>
</ul>
</div>
<div class="section level4">
<h4 id="configuration-precedence">Configuration precedence<a class="anchor" aria-label="anchor" href="#configuration-precedence"></a>
</h4>
<p>projr uses this precedence for configuration:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Environment variables</strong> (highest)</li>
<li>
<strong>Profile YAML</strong>
(<code>_projr-{profile}.yml</code>)</li>
<li>
<strong>Default YAML</strong> (<code>_projr.yml</code>)</li>
<li>
<strong>Built-in defaults</strong> (lowest)</li>
</ol>
<p><strong>Example</strong>:</p>
<pre><code># Built-in default
output: _output

# Overridden in _projr.yml
output: _my_output

# Overridden in _projr-dev.yml (if PROJR_PROFILE=dev)
output: _dev_output

# Overridden by environment variable (if set)
PROJR_OUTPUT_DIR=_temp_output</code></pre>
<p>Final value: <code>_temp_output</code></p>
<p><strong>Benefits</strong>:</p>
<ul>
<li>
<strong>Flexibility</strong>: Different contexts without editing
files</li>
<li>
<strong>Explicitness</strong>: Clear hierarchy of precedence</li>
<li>
<strong>Debuggability</strong>: Easy to trace where a setting comes
from</li>
</ul>
</div>
<div class="section level4">
<h4 id="manifest-format">Manifest format<a class="anchor" aria-label="anchor" href="#manifest-format"></a>
</h4>
<p>Manifests use CSV for simplicity and compatibility:</p>
<pre class="csv"><code>label,path,hash,version,timestamp
raw-data,_raw_data,abc123...,v0.1.0,2024-01-15T10:30:00Z</code></pre>
<p><strong>Why CSV?</strong></p>
<ul>
<li>
<strong>Universal</strong>: Readable by any tool (R, Python,
Excel)</li>
<li>
<strong>Simple</strong>: No complex parsing</li>
<li>
<strong>Diff-friendly</strong>: Git can show line-by-line
changes</li>
<li>
<strong>Human-readable</strong>: Open in text editor or
spreadsheet</li>
</ul>
<p><strong>Alternative considered</strong>: JSON</p>
<ul>
<li>✅ More structured</li>
<li>❌ Less human-readable</li>
<li>❌ Harder to diff</li>
<li>❌ Overkill for simple tabular data</li>
</ul>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="design-decisions">Design decisions<a class="anchor" aria-label="anchor" href="#design-decisions"></a>
</h3>
<div class="section level4">
<h4 id="why-semantic-versioning">Why semantic versioning?<a class="anchor" aria-label="anchor" href="#why-semantic-versioning"></a>
</h4>
<p><strong>Decision</strong>: Use x.y.z versioning
(major.minor.patch)</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Familiar</strong>: Most developers know SemVer</li>
<li>
<strong>Expressive</strong>: Can communicate scale of changes</li>
<li>
<strong>Tooling</strong>: Many tools understand SemVer</li>
</ul>
<p><strong>Alternative considered</strong>: Date-based versioning
(2024-01-15)</p>
<ul>
<li>✅ Chronological ordering</li>
<li>❌ Doesn’t communicate significance of changes</li>
<li>❌ Multiple versions per day require disambiguation</li>
</ul>
</div>
<div class="section level4">
<h4 id="why-default-to-github-releases">Why default to GitHub Releases?<a class="anchor" aria-label="anchor" href="#why-default-to-github-releases"></a>
</h4>
<p><strong>Decision</strong>: GitHub Releases is the default archive
destination</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Ubiquity</strong>: Most R projects already use GitHub</li>
<li>
<strong>Free</strong>: Unlimited public releases, generous private
quotas</li>
<li>
<strong>Integrated</strong>: Works with existing Git workflow</li>
<li>
<strong>Accessible</strong>: Web interface for downloads</li>
</ul>
<p><strong>Alternative considered</strong>: OSF as primary</p>
<ul>
<li>✅ Designed for research</li>
<li>✅ Better for large datasets</li>
<li>❌ Separate account/authentication</li>
<li>❌ Less familiar to R developers</li>
</ul>
<p><strong>Solution</strong>: Support both; default to GitHub for
familiarity.</p>
</div>
<div class="section level4">
<h4 id="why-clear-_output-before-builds">Why clear _output before builds?<a class="anchor" aria-label="anchor" href="#why-clear-_output-before-builds"></a>
</h4>
<p><strong>Decision</strong>: Default to clearing <code>_output</code>
before final builds</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Correctness</strong>: Ensures outputs match current
code</li>
<li>
<strong>No cruft</strong>: Old outputs don’t linger</li>
<li>
<strong>Idempotency</strong>: Same code → same outputs</li>
</ul>
<p><strong>Alternative considered</strong>: Incremental updates</p>
<ul>
<li>✅ Faster (only update changed files)</li>
<li>❌ Risk of stale files</li>
<li>❌ Non-deterministic (depends on previous state)</li>
</ul>
<p><strong>Solution</strong>: Clear by default; allow override via
<code>PROJR_OUTPUT_CLEAR</code>.</p>
</div>
<div class="section level4">
<h4 id="why-route-dev-builds-to-cache">Why route dev builds to cache?<a class="anchor" aria-label="anchor" href="#why-route-dev-builds-to-cache"></a>
</h4>
<p><strong>Decision</strong>: Dev builds write to
<code>_tmp/projr/v&lt;version&gt;/</code> not <code>_output</code></p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Safety</strong>: Can’t accidentally overwrite released
outputs</li>
<li>
<strong>Isolation</strong>: Multiple dev builds don’t conflict</li>
<li>
<strong>Cleanup</strong>: Cache can be deleted without losing
work</li>
</ul>
<p><strong>Alternative considered</strong>: Use <code>_output</code>
with flag to prevent overwrites</p>
<ul>
<li>✅ Simpler mental model (one output location)</li>
<li>❌ Risk of accidental overwrites</li>
<li>❌ Harder to keep dev and release outputs separate</li>
</ul>
</div>
<div class="section level4">
<h4 id="why-yaml-not-tomljson">Why YAML not TOML/JSON?<a class="anchor" aria-label="anchor" href="#why-yaml-not-tomljson"></a>
</h4>
<p><strong>Decision</strong>: Use YAML for configuration</p>
<p><strong>Rationale</strong>:</p>
<ul>
<li>
<strong>Familiar</strong>: Most R users know YAML (R Markdown,
pkgdown)</li>
<li>
<strong>Readable</strong>: Comments, no quotes on strings</li>
<li>
<strong>Expressive</strong>: Supports lists, nested structures</li>
</ul>
<p><strong>Alternatives considered</strong>:</p>
<p><strong>TOML</strong>: - ✅ Simpler syntax - ❌ Less familiar in R
ecosystem - ❌ Harder to nest deeply</p>
<p><strong>JSON</strong>: - ✅ Strict, machine-friendly - ❌ Less
human-readable (quotes, no comments) - ❌ Harder to hand-edit</p>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="future-directions">Future directions<a class="anchor" aria-label="anchor" href="#future-directions"></a>
</h3>
<div class="section level4">
<h4 id="potential-enhancements">Potential enhancements<a class="anchor" aria-label="anchor" href="#potential-enhancements"></a>
</h4>
<p>These are design considerations for future versions:</p>
<p><strong>1. Incremental builds</strong></p>
<p><strong>Idea</strong>: Only rebuild changed documents</p>
<p><strong>Pros</strong>: Faster builds, less re-rendering</p>
<p><strong>Cons</strong>: More complexity, risk of stale outputs</p>
<p><strong>Decision</strong>: Consider for v2.0 with careful
invalidation logic</p>
<p><strong>2. Dependency graphs</strong></p>
<p><strong>Idea</strong>: Track which outputs depend on which inputs</p>
<p><strong>Pros</strong>: Finer-grained rebuilding, better
traceability</p>
<p><strong>Cons</strong>: Complexity, requires analysing code</p>
<p><strong>Decision</strong>: Interesting but out-of-scope for now</p>
<p><strong>3. Remote execution</strong></p>
<p><strong>Idea</strong>: Build on CI/cloud instead of locally</p>
<p><strong>Pros</strong>: Reproducible environment, faster hardware</p>
<p><strong>Cons</strong>: Network dependency, setup complexity</p>
<p><strong>Decision</strong>: Possible via existing CI integrations
(GitHub Actions)</p>
<p><strong>4. Multi-language support</strong></p>
<p><strong>Idea</strong>: Support Python, Julia, etc., not just R</p>
<p><strong>Pros</strong>: Broader audience, more use cases</p>
<p><strong>Cons</strong>: Different ecosystems, more maintenance</p>
<p><strong>Decision</strong>: Focus on R first; generalise later if
demand exists</p>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="comparison-to-alternatives">Comparison to alternatives<a class="anchor" aria-label="anchor" href="#comparison-to-alternatives"></a>
</h3>
<div class="section level4">
<h4 id="projr-vs-targets">projr vs targets<a class="anchor" aria-label="anchor" href="#projr-vs-targets"></a>
</h4>
<p><strong>targets</strong>: Pipeline tool for dependency tracking</p>
<p><strong>Similarities</strong>: - Both focus on reproducibility - Both
integrate with R Markdown</p>
<p><strong>Differences</strong>: - <strong>targets</strong>: Focuses on
caching intermediate results - <strong>projr</strong>: Focuses on
versioning and archiving final outputs</p>
<p><strong>Use together?</strong> Yes! Use targets for complex
pipelines, projr for versioning and sharing.</p>
</div>
<div class="section level4">
<h4 id="projr-vs-workflowr">projr vs workflowr<a class="anchor" aria-label="anchor" href="#projr-vs-workflowr"></a>
</h4>
<p><strong>workflowr</strong>: Website-based project template</p>
<p><strong>Similarities</strong>: - Both provide project structure -
Both integrate with Git</p>
<p><strong>Differences</strong>: - <strong>workflowr</strong>: Focuses
on website generation - <strong>projr</strong>: Focuses on versioning
and archiving</p>
<p><strong>Use together?</strong> Potentially, though there’s overlap in
Git integration.</p>
</div>
<div class="section level4">
<h4 id="projr-vs-usethis">projr vs usethis<a class="anchor" aria-label="anchor" href="#projr-vs-usethis"></a>
</h4>
<p><strong>usethis</strong>: Package development infrastructure</p>
<p><strong>Similarities</strong>: - Both automate setup tasks - Both
follow conventions</p>
<p><strong>Differences</strong>: - <strong>usethis</strong>: For R
packages - <strong>projr</strong>: For research projects</p>
<p><strong>Use together?</strong> Yes! Use usethis for package
development, projr for analysis projects.</p>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="conclusion">Conclusion<a class="anchor" aria-label="anchor" href="#conclusion"></a>
</h3>
<p>projr’s design prioritises:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Simplicity</strong>: One function does everything</li>
<li>
<strong>Safety</strong>: Dev builds can’t break releases</li>
<li>
<strong>Transparency</strong>: Configuration is visible and
version-controlled</li>
<li>
<strong>Reproducibility</strong>: Automatic versioning and
archiving</li>
</ol>
<p>These principles guide every design decision, from directory
structure to function naming to configuration format.</p>
<p>The result is a tool that makes reproducible research easier than
non-reproducible research—which is exactly the point.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Miguel Rodo. Built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> and R</p>
</div>

<div class="pkgdown-footer-right">
  <p><a href="LICENSE.html">License</a> • projr is free and open source software</p>
</div>

    </footer>
</div>





  </body>
</html>
