\nonstopmode{}
\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\makeatletter\@ifl@t@r\fmtversion{2018/04/01}{}{\usepackage[utf8]{inputenc}}\makeatother
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `projr'}}
\par\bigskip{\large \today}
\end{center}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {projr: Facilitate reproducible and archived projects}}}{}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdfauthor = {Miguel Rodo}}}{}
\begin{description}
\raggedright{}
\item[Title]\AsIs{Facilitate reproducible and archived projects}
\item[Version]\AsIs{0.3.0-1}
\item[Maintainer]\AsIs{Miguel Rodo }\email{miguel.rodo@uct.ac.za}\AsIs{}
\item[Description]\AsIs{Facilitate reproducible and archived projects.}
\item[License]\AsIs{file LICENSE}
\item[Encoding]\AsIs{UTF-8}
\item[Roxygen]\AsIs{list(markdown = TRUE)}
\item[RoxygenNote]\AsIs{7.3.3}
\item[Imports]\AsIs{renv, jsonlite, yaml, rprojroot, desc, fs, digest, cli}
\item[Suggests]\AsIs{remotes, roxygen2, usethis, gert, gh, credentials, gitcreds,
piggyback, osfr, codemeta, cffr, pkgbuild, rmarkdown, bookdown,
knitr, quarto, testthat (>= 3.0.0), devtools, httr, covr,
htmltools, DT, rlang, withr, BiocManager}
\item[Config/testthat/edition]\AsIs{3}
\item[URL]\AsIs{}\url{https://satvilab.github.io/projr/}\AsIs{}
\item[VignetteBuilder]\AsIs{knitr}
\item[NeedsCompilation]\AsIs{no}
\item[Author]\AsIs{Miguel Rodo [aut, cre] (ORCID: <}\url{https://orcid.org/0000-0002-2036-4878}\AsIs{>)}
\item[Depends]\AsIs{R (>= 4.2.0)}
\end{description}
\Rdcontents{Contents}
\HeaderA{projr-package}{projr: Facilitate reproducible and archived projects}{projr.Rdash.package}
\aliasA{projr}{projr-package}{projr}
\keyword{internal}{projr-package}
%
\begin{Description}
Facilitate reproducible and archived projects.
\end{Description}
%
\begin{Author}
\strong{Maintainer}: Miguel Rodo \email{miguel.rodo@uct.ac.za} (\Rhref{https://orcid.org/0000-0002-2036-4878}{ORCID})

\end{Author}
%
\begin{SeeAlso}
Useful links:
\begin{itemize}

\item{} \url{https://satvilab.github.io/projr/}

\end{itemize}


\end{SeeAlso}
\HeaderA{.auth\_check\_github}{Check GitHub authentication}{.auth.Rul.check.Rul.github}
\keyword{internal}{.auth\_check\_github}
%
\begin{Description}
Checks if GitHub authentication is available. Throws an error if not.
Used internally before making GitHub API calls.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.auth_check_github(context = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{context}] Character string describing the operation context for error messages.
Default is NULL.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisible TRUE if authentication is available.
\end{Value}
\HeaderA{.auth\_check\_osf}{Check OSF authentication}{.auth.Rul.check.Rul.osf}
\keyword{internal}{.auth\_check\_osf}
%
\begin{Description}
Checks if OSF authentication is available. Throws an error if not.
Used internally before making OSF API calls.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.auth_check_osf(context = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{context}] Character string describing the operation context for error messages.
Default is NULL.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisible TRUE if authentication is available.
\end{Value}
\HeaderA{.build\_change\_summary\_display}{Display change summary during build}{.build.Rul.change.Rul.summary.Rul.display}
\keyword{internal}{.build\_change\_summary\_display}
%
\begin{Description}
Shows change summary at debug output level during the build process.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.build_change_summary_display(
  bump_component,
  output_level = "std",
  log_file = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bump\_component}] Character. Version bump component.

\item[\code{output\_level}] Character. Current output level.

\item[\code{log\_file}] Character. Path to log file (optional).
\end{ldescription}
\end{Arguments}
\HeaderA{.build\_change\_summary\_format\_label}{Format change summary for a single label}{.build.Rul.change.Rul.summary.Rul.format.Rul.label}
\keyword{internal}{.build\_change\_summary\_format\_label}
%
\begin{Description}
Format change summary for a single label
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.build_change_summary_format_label(
  label,
  change_list,
  n_added,
  n_removed,
  n_modified,
  n_unchanged
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{label}] Character. Directory label.

\item[\code{change\_list}] List. Output from .change\_get\_hash().

\item[\code{n\_added}] Integer. Number of added files.

\item[\code{n\_removed}] Integer. Number of removed files.

\item[\code{n\_modified}] Integer. Number of modified files.

\item[\code{n\_unchanged}] Integer. Number of unchanged files.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character vector of formatted lines.
\end{Value}
\HeaderA{.build\_change\_summary\_format\_section}{Format a section of the change summary (inputs or outputs)}{.build.Rul.change.Rul.summary.Rul.format.Rul.section}
\keyword{internal}{.build\_change\_summary\_format\_section}
%
\begin{Description}
Format a section of the change summary (inputs or outputs)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.build_change_summary_format_section(
  section_name,
  labels,
  manifest_all,
  version_prev,
  version_curr
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{section\_name}] Character. Name of the section ("Inputs" or "Outputs").

\item[\code{labels}] Character vector. Directory labels to check.

\item[\code{manifest\_all}] Data frame. The full manifest.

\item[\code{version\_prev}] Character. Previous version (no 'v' prefix).

\item[\code{version\_curr}] Character. Current version (no 'v' prefix).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character vector of formatted lines for this section.
\end{Value}
\HeaderA{.build\_change\_summary\_get}{Get change summary for build}{.build.Rul.change.Rul.summary.Rul.get}
\keyword{internal}{.build\_change\_summary\_get}
%
\begin{Description}
Compares the current build's manifest with the previous version's manifest
to identify what files have changed in input and output directories.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.build_change_summary_get(output_run)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{output\_run}] Logical. Whether this is an output build.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character vector of formatted change summary lines, or NULL if no previous version.
\end{Value}
\HeaderA{.build\_change\_summary\_get\_debug}{Get change summary for debug output}{.build.Rul.change.Rul.summary.Rul.get.Rul.debug}
\keyword{internal}{.build\_change\_summary\_get\_debug}
%
\begin{Description}
Similar to .build\_change\_summary\_get() but formatted for console output.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.build_change_summary_get_debug(output_run)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{output\_run}] Logical. Whether this is an output build.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
List with 'has\_changes' (logical) and 'message' (character vector).
\end{Value}
\HeaderA{.build\_change\_summary\_get\_previous\_version}{Get the previous version from manifest}{.build.Rul.change.Rul.summary.Rul.get.Rul.previous.Rul.version}
\keyword{internal}{.build\_change\_summary\_get\_previous\_version}
%
\begin{Description}
Get the previous version from manifest
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.build_change_summary_get_previous_version()
\end{verbatim}
\end{Usage}
%
\begin{Value}
Character version string (without 'v' prefix), or NULL if no previous version.
\end{Value}
\HeaderA{.build\_debug\_git\_info}{Output Git information for debug}{.build.Rul.debug.Rul.git.Rul.info}
\keyword{internal}{.build\_debug\_git\_info}
%
\begin{Description}
Output Git information for debug
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.build_debug_git_info(output_level = "std", log_file = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{output\_level}] Character. Current output level

\item[\code{log\_file}] Character. Path to log file
\end{ldescription}
\end{Arguments}
\HeaderA{.cli\_debug}{Show a debug message (only shown at debug level)}{.cli.Rul.debug}
\keyword{internal}{.cli\_debug}
%
\begin{Description}
Show a debug message (only shown at debug level)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_debug(..., output_level = "std", .envir = parent.frame(), log_file = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] Message components passed to cli::cli\_text

\item[\code{output\_level}] Character. Current output level.

\item[\code{.envir}] Environment for variable evaluation

\item[\code{log\_file}] Character. Path to log file (optional).
\end{ldescription}
\end{Arguments}
\HeaderA{.cli\_info}{Show a standard informational message}{.cli.Rul.info}
\keyword{internal}{.cli\_info}
%
\begin{Description}
Show a standard informational message
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_info(..., output_level = "std", .envir = parent.frame(), log_file = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] Message components passed to cli::cli\_alert\_info

\item[\code{output\_level}] Character. Current output level.

\item[\code{.envir}] Environment for variable evaluation

\item[\code{log\_file}] Character. Path to log file (optional).
\end{ldescription}
\end{Arguments}
\HeaderA{.cli\_output\_level\_get}{Get the current output level}{.cli.Rul.output.Rul.level.Rul.get}
\keyword{internal}{.cli\_output\_level\_get}
%
\begin{Description}
Get the current output level
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_output_level_get(output_level = NULL, output_run = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{output\_level}] Character. Explicit output level ("none", "std", "debug").
If NULL, determined from environment variable PROJR\_OUTPUT\_LEVEL.

\item[\code{output\_run}] Logical. Whether this is an output build (vs dev build).
Used to set default if output\_level is NULL.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character. The output level to use.
\end{Value}
\HeaderA{.cli\_process\_done}{Mark a process as done}{.cli.Rul.process.Rul.done}
\keyword{internal}{.cli\_process\_done}
%
\begin{Description}
Mark a process as done
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_process_done(
  id = NULL,
  msg_done = NULL,
  msg_failed = NULL,
  .envir = parent.frame(),
  output_level = "std"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{id}] Process ID from cli\_process\_start

\item[\code{msg\_done}] Success message

\item[\code{msg\_failed}] Failure message

\item[\code{.envir}] Environment for the process

\item[\code{output\_level}] Character. Current output level.
\end{ldescription}
\end{Arguments}
\HeaderA{.cli\_process\_start}{Start a process with a spinner/status indicator}{.cli.Rul.process.Rul.start}
\keyword{internal}{.cli\_process\_start}
%
\begin{Description}
Start a process with a spinner/status indicator
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_process_start(..., output_level = "std")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] Message components

\item[\code{output\_level}] Character. Current output level.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Process ID for cli\_process\_done
\end{Value}
\HeaderA{.cli\_should\_show}{Check if messages should be shown at the given level}{.cli.Rul.should.Rul.show}
\keyword{internal}{.cli\_should\_show}
%
\begin{Description}
Check if messages should be shown at the given level
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_should_show(required_level, current_level)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{required\_level}] Character. The level required for the message.

\item[\code{current\_level}] Character. The current output level.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Logical. TRUE if the message should be shown.
\end{Value}
\HeaderA{.cli\_stage\_header}{Show a stage header}{.cli.Rul.stage.Rul.header}
\keyword{internal}{.cli\_stage\_header}
%
\begin{Description}
Show a stage header
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_stage_header(
  stage_name,
  build_type = "output",
  output_level = "std",
  log_file = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{stage\_name}] Character. Name of the build stage.

\item[\code{build\_type}] Character. Type of build ("dev" or "output").

\item[\code{output\_level}] Character. Current output level.

\item[\code{log\_file}] Character. Path to log file (optional).
\end{ldescription}
\end{Arguments}
\HeaderA{.cli\_step}{Show a step message (sub-item in a stage)}{.cli.Rul.step}
\keyword{internal}{.cli\_step}
%
\begin{Description}
Show a step message (sub-item in a stage)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_step(..., output_level = "std", .envir = parent.frame(), log_file = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] Message components passed to cli::cli\_li

\item[\code{output\_level}] Character. Current output level.

\item[\code{.envir}] Environment for variable evaluation

\item[\code{log\_file}] Character. Path to log file (optional).
\end{ldescription}
\end{Arguments}
\HeaderA{.cli\_success}{Show a success message}{.cli.Rul.success}
\keyword{internal}{.cli\_success}
%
\begin{Description}
Show a success message
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.cli_success(
  ...,
  output_level = "std",
  .envir = parent.frame(),
  log_file = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] Message components passed to cli::cli\_alert\_success

\item[\code{output\_level}] Character. Current output level.

\item[\code{.envir}] Environment for variable evaluation

\item[\code{log\_file}] Character. Path to log file (optional).
\end{ldescription}
\end{Arguments}
\HeaderA{.git\_branch\_get}{Get current Git branch name}{.git.Rul.branch.Rul.get}
\keyword{internal}{.git\_branch\_get}
%
\begin{Description}
Get current Git branch name
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.git_branch_get()
\end{verbatim}
\end{Usage}
%
\begin{Value}
Character string with branch name, or NULL if not in a Git repo
\end{Value}
\HeaderA{.git\_last\_commit\_get}{Get last commit information}{.git.Rul.last.Rul.commit.Rul.get}
\keyword{internal}{.git\_last\_commit\_get}
%
\begin{Description}
Get last commit information
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.git_last_commit_get()
\end{verbatim}
\end{Usage}
%
\begin{Value}
List with sha and message, or NULL if not in a Git repo
\end{Value}
\HeaderA{.git\_untracked\_not\_ignored\_get}{Get untracked files that are not ignored}{.git.Rul.untracked.Rul.not.Rul.ignored.Rul.get}
\keyword{internal}{.git\_untracked\_not\_ignored\_get}
%
\begin{Description}
Get untracked files that are not ignored
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.git_untracked_not_ignored_get()
\end{verbatim}
\end{Usage}
%
\begin{Value}
Character vector of untracked file paths that are not ignored
\end{Value}
\HeaderA{.log\_build\_append}{Append message to build log}{.log.Rul.build.Rul.append}
\keyword{internal}{.log\_build\_append}
%
\begin{Description}
Append message to build log
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_build_append(log_file, message, level = "info")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{log\_file}] Character. Path to log file.

\item[\code{message}] Character. Message to append.

\item[\code{level}] Character. Message level (info, debug, success, etc.)
\end{ldescription}
\end{Arguments}
\HeaderA{.log\_build\_finalize}{Finalize build log with summary}{.log.Rul.build.Rul.finalize}
\keyword{internal}{.log\_build\_finalize}
%
\begin{Description}
Finalize build log with summary
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_build_finalize(log_file, success = TRUE, start_time = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{log\_file}] Character. Path to log file.

\item[\code{success}] Logical. Whether build succeeded.

\item[\code{start\_time}] POSIXct. Build start time.
\end{ldescription}
\end{Arguments}
\HeaderA{.log\_build\_init}{Initialize a build log file}{.log.Rul.build.Rul.init}
\keyword{internal}{.log\_build\_init}
%
\begin{Description}
Initialize a build log file
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_build_init(
  build_type = "output",
  bump_component = NULL,
  msg = "",
  output_level = "std"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{build\_type}] Character. Either "output" or "dev".

\item[\code{bump\_component}] Character. Version bump component.

\item[\code{msg}] Character. Build message.

\item[\code{output\_level}] Character. Output level for this build.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
List with log\_file path and timestamp, or NULL if logging disabled.
\end{Value}
\HeaderA{.log\_build\_section}{Append section header to build log}{.log.Rul.build.Rul.section}
\keyword{internal}{.log\_build\_section}
%
\begin{Description}
Append section header to build log
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_build_section(log_file, section_name)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{log\_file}] Character. Path to log file.

\item[\code{section\_name}] Character. Name of the section.
\end{ldescription}
\end{Arguments}
\HeaderA{.log\_clear\_history}{Clear history file with filters}{.log.Rul.clear.Rul.history}
\keyword{internal}{.log\_clear\_history}
%
\begin{Description}
Clear history file with filters
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_clear_history(build_type, before_date = NULL, before_version = NULL)
\end{verbatim}
\end{Usage}
\HeaderA{.log\_clear\_output}{Clear output logs with filters}{.log.Rul.clear.Rul.output}
\keyword{internal}{.log\_clear\_output}
%
\begin{Description}
Clear output logs with filters
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_clear_output(build_type, before_date = NULL, before_version = NULL)
\end{verbatim}
\end{Usage}
\HeaderA{.log\_clear\_output\_by\_date}{Clear output logs before a specific date}{.log.Rul.clear.Rul.output.Rul.by.Rul.date}
\keyword{internal}{.log\_clear\_output\_by\_date}
%
\begin{Description}
Clear output logs before a specific date
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_clear_output_by_date(output_dir, before_date)
\end{verbatim}
\end{Usage}
\HeaderA{.log\_dir\_get\_base}{Get the base log directory path}{.log.Rul.dir.Rul.get.Rul.base}
\keyword{internal}{.log\_dir\_get\_base}
%
\begin{Description}
Get the base log directory path
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_dir_get_base()
\end{verbatim}
\end{Usage}
%
\begin{Value}
Character. Path to the log directory.
\end{Value}
\HeaderA{.log\_dir\_get\_output\_date}{Get output log directory for a specific date}{.log.Rul.dir.Rul.get.Rul.output.Rul.date}
\keyword{internal}{.log\_dir\_get\_output\_date}
%
\begin{Description}
Get output log directory for a specific date
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_dir_get_output_date(build_type = "output", date = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{build\_type}] Character. Either "output" or "dev".

\item[\code{date}] Character. Date in YYYY-MMM-DD format. Default is today.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character. Path to the date-specific output directory.
\end{Value}
\HeaderA{.log\_dir\_get\_type}{Get log directory for build type}{.log.Rul.dir.Rul.get.Rul.type}
\keyword{internal}{.log\_dir\_get\_type}
%
\begin{Description}
Get log directory for build type
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_dir_get_type(build_type = "output", create = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{build\_type}] Character. Either "output" or "dev".

\item[\code{create}] Logical. Create directory if it doesn't exist.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character. Path to the build type log directory.
\end{Value}
\HeaderA{.log\_enabled}{Check if detailed logging is enabled}{.log.Rul.enabled}
\keyword{internal}{.log\_enabled}
%
\begin{Description}
Check if detailed logging is enabled
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_enabled()
\end{verbatim}
\end{Usage}
%
\begin{Value}
Logical. TRUE if detailed logging should be written.
\end{Value}
\HeaderA{.log\_file\_get\_history}{Get history log file path}{.log.Rul.file.Rul.get.Rul.history}
\keyword{internal}{.log\_file\_get\_history}
%
\begin{Description}
Get history log file path
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_file_get_history(build_type = "output")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{build\_type}] Character. Either "output" or "dev".
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character. Path to the history markdown file.
\end{Value}
\HeaderA{.log\_file\_get\_output}{Get output log file path for current build}{.log.Rul.file.Rul.get.Rul.output}
\keyword{internal}{.log\_file\_get\_output}
%
\begin{Description}
Get output log file path for current build
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_file_get_output(build_type = "output", timestamp = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{build\_type}] Character. Either "output" or "dev".

\item[\code{timestamp}] Character. Timestamp in HH-MM-SS format. Default is now.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character. Path to the log file for this build.
\end{Value}
\HeaderA{.log\_history\_add}{Update build history file}{.log.Rul.history.Rul.add}
\keyword{internal}{.log\_history\_add}
%
\begin{Description}
Update build history file
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.log_history_add(
  build_type = "output",
  bump_component = NULL,
  msg = "",
  success = TRUE,
  log_file = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{build\_type}] Character. Either "output" or "dev".

\item[\code{bump\_component}] Character. Version bump component.

\item[\code{msg}] Character. Build message.

\item[\code{success}] Logical. Whether build succeeded.

\item[\code{log\_file}] Character. Path to detailed log file.
\end{ldescription}
\end{Arguments}
\HeaderA{.yml\_get}{Get active \code{projr} settings and do no check}{.yml.Rul.get}
%
\begin{Description}
A list of the active \code{projr} settings,
without doing any error checking.
Gets active \code{projr} settings, which merges settings and resolves conflicts
between local (\AsIs{\texttt{\_projr-local.yml}}), profile (\AsIs{\texttt{\_projr-<projr>.yml}} or as
- keys in \AsIs{\texttt{\_projr.yml}})
and default (\AsIs{\texttt{\_projr.yml}}) settings.
Where there are conflicts, local settings has highest precedence
(i.e. are always preferred) and default settings have lowest precedence
(i.e. are never preferred).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.yml_get(profile)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] character.
If supplied, the specific profile file to read in.
"default" loads \AsIs{\texttt{\_projr.yml}}, but another value
loads \AsIs{\texttt{\_projr-<profile>.yml}}.
If NULL, then the active profile is used.
It not supplied, then treated as \code{NULL}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A named list.
\end{Value}
%
\begin{SeeAlso}
.yml\_get.yml\_check
\end{SeeAlso}
\HeaderA{.yml\_scripts\_get}{Get build scripts from YAML configuration}{.yml.Rul.scripts.Rul.get}
\keyword{internal}{.yml\_scripts\_get}
%
\begin{Description}
Get build scripts from YAML configuration
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.yml_scripts_get(profile)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] Profile name
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Vector of script paths or NULL
\end{Value}
\HeaderA{.yml\_scripts\_get\_build}{Get list of scripts to build for production builds}{.yml.Rul.scripts.Rul.get.Rul.build}
\keyword{internal}{.yml\_scripts\_get\_build}
%
\begin{Description}
Scripts go directly under build.scripts (no sub-keys allowed)
Format: scripts: c("file1.qmd", "file2.qmd")
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.yml_scripts_get_build(profile)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] Profile name
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Vector of script paths to build or NULL
\end{Value}
\HeaderA{.yml\_scripts\_get\_dev}{Get list of scripts to build for dev builds}{.yml.Rul.scripts.Rul.get.Rul.dev}
\keyword{internal}{.yml\_scripts\_get\_dev}
%
\begin{Description}
Checks dev.scripts first, falls back to build.scripts if not set
\end{Description}
%
\begin{Usage}
\begin{verbatim}
.yml_scripts_get_dev(profile)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] Profile name
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Vector of script paths to build or NULL
\end{Value}
\HeaderA{projr\_build}{Build project to output}{projr.Rul.build}
\aliasA{projr\_build\_major}{projr\_build}{projr.Rul.build.Rul.major}
\aliasA{projr\_build\_minor}{projr\_build}{projr.Rul.build.Rul.minor}
\aliasA{projr\_build\_patch}{projr\_build}{projr.Rul.build.Rul.patch}
%
\begin{Description}
.build\_output` Builds project to output, which
means recording the input and output data hashes,
building the actual bookdown document and
saving and archiving selected output.

.build\_major\AsIs{\texttt{, .build\_minor}} and .build\_patch\AsIs{\texttt{ are wrappers around .build\_output}} with the version component
bumped set automatically, e.g. projr\_build\_major()\AsIs{\texttt{ is equivalent projr\_build(bump\_component = "major")}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_build(
  bump_component,
  msg = NULL,
  args_engine = list(),
  profile = NULL,
  archive_github = FALSE,
  archive_local = FALSE,
  always_archive = TRUE,
  clear_output = NULL,
  output_level = NULL
)

projr_build_major(
  msg = NULL,
  args_engine = list(),
  profile = NULL,
  archive_github = FALSE,
  archive_local = FALSE,
  always_archive = TRUE,
  clear_output = NULL,
  output_level = NULL
)

projr_build_minor(
  msg = NULL,
  args_engine = list(),
  profile = NULL,
  archive_github = FALSE,
  archive_local = FALSE,
  always_archive = TRUE,
  clear_output = NULL,
  output_level = NULL
)

projr_build_patch(
  msg = NULL,
  args_engine = list(),
  profile = NULL,
  archive_github = FALSE,
  archive_local = FALSE,
  always_archive = TRUE,
  clear_output = NULL,
  output_level = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{bump\_component}] "major", "minor", "patch" or missing.
Specifies version component to increment.
If missing, then is set equal to the lowest version component
in used version format.
No default (i.e. is missing by default).

\item[\code{msg}] character.
Message to append to Git commit messages.
Default is \code{NULL}, in which
case the user is prompted for a message or,
if the session is not interactive, it is
left empty.
Default is \code{NULL}.
Note that the Git messages in this case would not be blank -
they would simply consist of details as to the version
being bumped to and the stage in the build process
at which the commit was made.

\item[\code{args\_engine}] list.
Arguments passed to the
rendering engine
(\code{rmarkdown::render}, \code{quarto::render} or \code{bookdown::render\_book}).

\item[\code{profile}] character.
\code{projr} profile to use. Will set the environment variable
.PROFILE` to this value at the start of the build,

\item[\code{archive\_github}] \code{TRUE},\code{FALSE} orcharacter vector of
directory labels.
If \code{TRUE}, then all directories (\code{raw-data}, \code{output}, etc)
are uploaded to a GitHub release named \code{archive}
as versioned files (e.g. \code{output-v0.1.2.zip}).
If \code{FALSE}, then no directories are uploaded.
If a character vector, then only the directories
specified are uploaded.
Default is \code{FALSE}.
Ignored if there is a release named \code{archive}
already specified as a destination in
the \code{projr} configuration file.

\item[\code{archive\_local}] \code{TRUE}, \code{FALSE} or character vector of
directory labels.
If \code{TRUE}, then all directories (\code{raw-data}, \code{output}, etc)
are archived to a local directory.
If \code{FALSE}, then no directories are archived locally.
If a character vector, then only the directories
specified are archived.
Default is \code{FALSE}.

\item[\code{always\_archive}] logical.
If \code{TRUE}, then the directories are uploaded
regardless of whether the directory to be uploaded
has exactly the same contents as the latest version
of the directory on the GitHub release.
Default is \code{TRUE}.
Ignored if there is a release named \code{archive}
already specified as a destination in
the \code{projr} configuration file.

\item[\code{clear\_output}] character.
When to clear output directories: "pre" (before build, default),
"post" (after build), or "never".
Can also be set via PROJR\_CLEAR\_OUTPUT environment variable.

\item[\code{output\_level}] character.
Level of CLI output: "none" (no additional messages),
"std" (standard messages, default for output builds), or
"debug" (verbose messages for debugging).
Can also be set via PROJR\_OUTPUT\_LEVEL environment variable.
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_build\_dev}{Build dev project}{projr.Rul.build.Rul.dev}
%
\begin{Description}
Builds project to output, which
means recording the input and output data hashes,
building the actual bookdown document and
saving and archiving selected output.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_build_dev(
  file = NULL,
  bump = FALSE,
  old_dev_remove = TRUE,
  args_engine = list(),
  profile = NULL,
  clear_output = "never",
  output_level = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{file}] character vector.
Paths to files to build.
Paths may be relative to project root, or absolute.
Default is NULL, in which case all files are built.

\item[\code{bump}] logical.
Whether to increment dev version for build.
Default is \code{FALSE}.

\item[\code{old\_dev\_remove}] logical.
If \code{TRUE}, then previous development builds are deleted
after a successful run.

\item[\code{args\_engine}] list.
Arguments passed to the
rendering engine
(\code{rmarkdown::render}, \code{quarto::render} or \code{bookdown::render\_book}).

\item[\code{profile}] character.
\code{projr} profile to use. Will set the environment variable
.PROFILE` to this value at the start of the build,

\item[\code{clear\_output}] character.
When to clear output directories: "pre" (before build),
"post" (after build), or "never" (default for dev builds).
Can also be set via PROJR\_CLEAR\_OUTPUT environment variable.

\item[\code{output\_level}] character.
Level of CLI output: "none" (no additional messages, default for dev builds),
"std" (standard messages), or "debug" (verbose messages for debugging).
Can also be set via PROJR\_OUTPUT\_LEVEL environment variable.
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_cat\_changelog}{Cat useful information}{projr.Rul.cat.Rul.changelog}
%
\begin{Description}
Cat useful information.
.cat\_changelog`:
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_cat_changelog(n_row = 10)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{n\_row}] integer.
Number of rows to cat.
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_env\_set}{Set environment variables from files}{projr.Rul.env.Rul.set}
%
\begin{Description}
Activate environment variables by reading default values from a set of files.
If \code{file} is \code{NULL},
all existing files are used in order of decreasing priority:
first \AsIs{\texttt{\_environment.local}} (machine-specific overrides),
then any \AsIs{\texttt{\_environment-<profile>}} files (profile-specific),
and finally \AsIs{\texttt{\_environment}} (global defaults).

The profiles activated are those set in the \code{QUARTO\_PROFILE}
and the \code{PROJR\_PROFILE} environment variables, with
\code{QUARTO\_PROFILE} priorities.
The \code{QUARTO\_PROFILE} variable can specify multiple profiles,
separated by commas.
The \code{PROJR\_PROFILE} variable can also specify multiple profiles,
separated by either commas or semi-colons.
In both cases, the earlier profile takes precedence, e.g.
\AsIs{\texttt{QUARTO\_PROFILE=test,basic}} will activate the \code{test} profile first.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_env_set(file = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{file}] character vector.
Paths to files with environment variables to activate.
If provided, only these files will be read; otherwise the default set
(\AsIs{\texttt{\_environment.local}}, \AsIs{\texttt{\_environment-<profile>}}, \AsIs{\texttt{\_environment}}) is used.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisibly returns \code{TRUE} if any files were successfully activated,
or \code{FALSE} if none existed.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
# Activate only the local overrides
## Not run: 
  projr_env_set("_environment.local")

## End(Not run)
# Activate all available defaults in the standard order
## Not run: 
  projr_env_set()

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_ignore}{Manually Ignore Files or Directories in \code{.gitignore} and \code{.Rbuildignore}}{projr.Rul.ignore}
\aliasA{projr\_ignore\_dir}{projr\_ignore}{projr.Rul.ignore.Rul.dir}
\aliasA{projr\_ignore\_dir\_git}{projr\_ignore}{projr.Rul.ignore.Rul.dir.Rul.git}
\aliasA{projr\_ignore\_dir\_rbuild}{projr\_ignore}{projr.Rul.ignore.Rul.dir.Rul.rbuild}
\aliasA{projr\_ignore\_file}{projr\_ignore}{projr.Rul.ignore.Rul.file}
\aliasA{projr\_ignore\_file\_git}{projr\_ignore}{projr.Rul.ignore.Rul.file.Rul.git}
\aliasA{projr\_ignore\_file\_rbuild}{projr\_ignore}{projr.Rul.ignore.Rul.file.Rul.rbuild}
%
\begin{Description}
These functions allow manual addition of files and directories to the
\code{.gitignore} and \code{.Rbuildignore} files, outside of the automatic management
provided by the \code{projr} package.
\begin{itemize}

\item{} \code{projr\_ignore}: General function to add both files and directories
to both \code{.gitignore} and \code{.Rbuildignore}. If a path does not exist, it is
treated as a file.
\item{} \code{projr\_ignore\_dir}: Specifically adds directories to both \code{.gitignore}
and \code{.Rbuildignore}.
\item{} \code{projr\_ignore\_file}: Specifically adds files to both \code{.gitignore}
and \code{.Rbuildignore}.
\item{} \code{projr\_ignore\_dir\_git} and \code{projr\_ignore\_file\_git}: Add
directories or files explicitly to \code{.gitignore}.
\item{} \code{projr\_ignore\_dir\_rbuild} and \code{projr\_ignore\_file\_rbuild}: Add
directories or files explicitly to \code{.Rbuildignore}.

\end{itemize}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_ignore(ignore, force_create = TRUE)

projr_ignore_dir(ignore, force_create = TRUE)

projr_ignore_file(ignore)

projr_ignore_file_git(ignore, force_create = TRUE)

projr_ignore_dir_git(ignore, force_create = TRUE)

projr_ignore_file_rbuild(ignore, force_create = TRUE)

projr_ignore_dir_rbuild(ignore, force_create = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ignore}] A character vector of file or directory paths to be ignored.
Paths must be valid non-empty strings.

\item[\code{force\_create}] logical.
If \code{FALSE}, then the function will only add to the corresponding
ignore file (\code{.gitignore}/\code{.Rbuildignore}) if it already exists, OR
if it is warranted
(i.e. if there is a Git repository or DESCRIPTION file, respectively).
If \code{TRUE}, then the function will create the ignore file
if it does not exist,
even if there is no Git repository or DESCRIPTION file,
and will add the specified paths to it.
Default is \code{TRUE}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
These functions provide fine-grained control for cases where users want to
manually ignore specific paths permanently. They do not interact with the
automated ignore management system of \code{projr}.
\begin{itemize}

\item{} Non-existent paths provided to \code{projr\_ignore} are assumed to be files.
\item{} For \code{.gitignore}, directories are automatically appended with \AsIs{\texttt{/**}} if
missing, ensuring proper Git ignore syntax.
\item{} For \code{.Rbuildignore}, paths are converted to regular expressions using
\code{glob2rx} for compatibility with R's build tools.

\end{itemize}

\end{Details}
%
\begin{Value}
Invisibly returns \code{TRUE} if the operation succeeds, or \code{FALSE} if the input
contains invalid (empty) paths.
\end{Value}
%
\begin{SeeAlso}
\code{projr\_ignore\_auto} for dynamically managed ignore entries, and \code{projr\_unignore\_manual}
for forcing certain paths to not be ignored.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Manually ignore files and directories
projr_ignore(c("output", "tempfile.log"))

# Specifically ignore directories
projr_ignore_dir("data")

# Specifically ignore files
projr_ignore_file("README.md")

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_ignore\_auto}{Update \code{.gitignore} and \code{.Rbuildignore} with projr-managed ignores}{projr.Rul.ignore.Rul.auto}
%
\begin{Description}
The projr\_ignore\_auto()\AsIs{\texttt{function updates the projectâ€™s}}.gitignore\code{and}.Rbuildignore` files to reflect directories and files managed by
projr, as well as
other directories and files that should
clearly be ignored.
They are kept up-to-date with the project's configuration,
and are written within a demarcated section of the file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_ignore_auto()
\end{verbatim}
\end{Usage}
%
\begin{Value}
Called primarily for its side effects (modifying
\code{.gitignore} and/or \code{.Rbuildignore}). Returns \code{TRUE} invisibly.
\end{Value}
%
\begin{SeeAlso}
.ignore\_add.ignore\_add\_git.ignore\_add\_rbuild
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
projr_ignore_auto()

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_init}{Initialize a projr Project}{projr.Rul.init}
\aliasA{projr\_init\_all}{projr\_init}{projr.Rul.init.Rul.all}
\aliasA{projr\_init\_cite}{projr\_init}{projr.Rul.init.Rul.cite}
\aliasA{projr\_init\_git}{projr\_init}{projr.Rul.init.Rul.git}
\aliasA{projr\_init\_github}{projr\_init}{projr.Rul.init.Rul.github}
\aliasA{projr\_init\_license}{projr\_init}{projr.Rul.init.Rul.license}
\aliasA{projr\_init\_renv}{projr\_init}{projr.Rul.init.Rul.renv}
%
\begin{Description}
This function performs a full initialization of a projr project. It sets up the project
structure by creating directories, generating a README (in Markdown or R Markdown format),
configuring a renv environment, writing a DESCRIPTION file, applying a license (if provided),
setting up citation files, creating a projr configuration YAML file, establishing literate documentation,
and configuring both Git and GitHub repositories.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_init(
  git = TRUE,
  git_commit = TRUE,
  github = TRUE,
  github_public = FALSE,
  github_org = NULL,
  dir = TRUE,
  readme = TRUE,
  readme_rmd = TRUE,
  desc = FALSE,
  license = NULL,
  projr_yml = FALSE,
  lit_doc = NULL
)

projr_init_all(github_org = NULL, license = NULL, lit_doc = NULL)

projr_init_renv(bioc = TRUE)

projr_init_cite()

projr_init_git(commit = TRUE)

projr_init_github(username = NULL, public = FALSE)

projr_init_license(license, first_name, last_name)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{git}] Logical. If \code{TRUE}, initializes a Git repository. Defaults to \code{TRUE}.

\item[\code{git\_commit}] Logical. If \code{TRUE}, commits the initial changes to the Git repository.
Defaults to \code{TRUE}.

\item[\code{github}] Logical. If \code{TRUE}, attempts to create a GitHub repository for the project.
Defaults to \code{TRUE}.

\item[\code{github\_public}] Logical. If \code{TRUE}, the GitHub repository will be public.
Defaults to \code{FALSE}.

\item[\code{github\_org}] Character or \code{NULL}. The GitHub organization under which to create
the repository. Defaults to \code{NULL}, which creates the repository under the user's account
(as implied by the GitHub token).

\item[\code{dir}] Logical. If \code{TRUE}, initializes the projr-specified directories (e.g., raw,
cache, output). Defaults to \code{TRUE}.

\item[\code{readme}] Logical. If \code{TRUE}, creates a README file. Defaults to \code{TRUE}.

\item[\code{readme\_rmd}] Logical. If \code{TRUE}, generates a README in R Markdown format
(\code{README.Rmd}); otherwise, a Markdown file (\code{README.md}) is created.
Defaults to \code{TRUE}.

\item[\code{desc}] Logical. If \code{TRUE}, creates a DESCRIPTION file for the project.
Defaults to \code{FALSE}.

\item[\code{license}] Character or \code{NULL}. Specifies the license to apply (e.g., \code{"ccby"},
\code{"apache"}, \code{"cc0"}, \code{"proprietary"}). Defaults to \code{NULL}.

\item[\code{projr\_yml}] Logical. If \code{TRUE}, creates a \code{projr.yml} configuration file.
Defaults to \code{FALSE}.

\item[\code{lit\_doc}] Character or \code{NULL}. Specifies the type of literate documentation to create.
Supported values are \code{"bookdown"}, \code{"project"}, \code{"quarto"}, and \code{"rmd"}.
Defaults to \code{NULL}.

\item[\code{bioc}] Logical (for \code{projr\_init\_renv}). If \code{TRUE}, includes Bioconductor packages
in the renv setup. Defaults to \code{TRUE}.

\item[\code{commit}] Logical (for \code{projr\_init\_git}). If \code{TRUE}, commits the initial changes
to the Git repository. Defaults to \code{TRUE}.

\item[\code{username}] Character or \code{NULL} (for \code{projr\_init\_github}). The GitHub username or
organization under which to create the repository. Defaults to \code{NULL}.

\item[\code{public}] Logical (for \code{projr\_init\_github}). If \code{TRUE}, the GitHub repository will
be public. Defaults to \code{FALSE}.

\item[\code{first\_name}] Character (for \code{projr\_init\_license}). First name for proprietary license.
Required when \code{license = "proprietary"}.

\item[\code{last\_name}] Character (for \code{projr\_init\_license}). Last name for proprietary license.
Required when \code{license = "proprietary"}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
The \code{projr\_init} function is a wrapper that calls several helper functions to
perform the following tasks:
\begin{itemize}

\item{} Prevent working directory errors by ensuring the \pkg{usethis} project is set.
\item{} Create project directories.
\item{} Generate a README file (in Markdown or R Markdown format).
\item{} Initialize a renv environment, optionally with Bioconductor support.
\item{} Write a DESCRIPTION file for project metadata.
\item{} Apply a specified license.
\item{} Configure citation files (if a DESCRIPTION file exists).
\item{} Create a projr configuration YAML file.
\item{} Set up literate documentation in the chosen format.
\item{} Initialize Git (and optionally commit initial changes).
\item{} Create a GitHub repository if requested.

\end{itemize}

\end{Details}
%
\begin{Value}
Invisibly returns \code{TRUE} if initialization is successful, or \code{FALSE} if
a particular step is skipped.
\end{Value}
\HeaderA{projr\_init\_prompt}{Initialise project}{projr.Rul.init.Rul.prompt}
%
\begin{Description}
Initialise project
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_init_prompt(
  yml_path_from = NULL,
  renv_force = FALSE,
  renv_bioconductor = TRUE,
  public = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{yml\_path\_from}] character.
Path to YAML file to use as \AsIs{\texttt{\_projr.yml}}.
If not supplied, then default \AsIs{\texttt{\_projr.yml}}
file is used.

\item[\code{renv\_force}] Logical.
Passed to \code{renv::init()}.
If \code{FALSE}, then \code{renv::init()} will not run
if it detects that the working directory
already is registered with renv.
Default is \code{FALSE}.

\item[\code{renv\_bioconductor}] Logical.
Whether \code{renv} should look for packages
on Bioconductor.
Default is \code{TRUE}.

\item[\code{public}] logical.
Whether the GitHub repo created (if any)
is public or not.
Default is \code{FALSE}.
\end{ldescription}
\end{Arguments}
%
\begin{SeeAlso}
.init\_renviron
\end{SeeAlso}
\HeaderA{projr\_init\_renviron}{Set environment variables for projr\_init}{projr.Rul.init.Rul.renviron}
%
\begin{Description}
Set environment variables for \code{projr\_init.}
When set, \code{projr\_init} will use these variables
to provide options to populate the metadata.
This function creates the \code{.Renviron} file
for the user if it does not exist.
It then adds the variables to the \code{.Renviron} file
without any values set.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_init_renviron()
\end{verbatim}
\end{Usage}
\HeaderA{projr\_instr\_auth\_github}{Two-minutes or less authorisation instructions}{projr.Rul.instr.Rul.auth.Rul.github}
\aliasA{projr\_instr\_auth\_osf}{projr\_instr\_auth\_github}{projr.Rul.instr.Rul.auth.Rul.osf}
%
\begin{Description}
.instr\_auth\_github\AsIs{\texttt{ and .instr\_auth\_osf}} print easy-to-follow,
step-by-step instructions for authorisation
to GitHub and OSF.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_instr_auth_github()

projr_instr_auth_osf()
\end{verbatim}
\end{Usage}
\HeaderA{projr\_log\_clear}{Clear build logs}{projr.Rul.log.Rul.clear}
%
\begin{Description}
Delete build logs based on specified criteria.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_log_clear(
  build_type = "all",
  history = TRUE,
  output = TRUE,
  before_date = NULL,
  before_version = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{build\_type}] Character. Either "output", "dev", or "all".
Default is "all".

\item[\code{history}] Logical. Clear history files. Default is TRUE.

\item[\code{output}] Logical. Clear output log files. Default is TRUE.

\item[\code{before\_date}] Character. Clear logs before this date (YYYY-MM-DD).
Default is NULL (no date filter).

\item[\code{before\_version}] Character. Clear logs before this version.
Default is NULL (no version filter).
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_manifest\_changes}{Query Files Changed Between Versions}{projr.Rul.manifest.Rul.changes}
\aliasA{projr\_manifest\_last\_change}{projr\_manifest\_changes}{projr.Rul.manifest.Rul.last.Rul.change}
\aliasA{projr\_manifest\_range}{projr\_manifest\_changes}{projr.Rul.manifest.Rul.range}
%
\begin{Description}
Query which files changed between two project versions based on the manifest.
Returns files that were added, modified, or removed between the versions.

Query which files changed across a range of versions.
For each file, shows the version where it last changed.

Query when files in each directory last changed.
Shows the most recent version where any file in the directory was modified.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_manifest_changes(version_from = NULL, version_to = NULL, label = NULL)

projr_manifest_range(version_start = NULL, version_end = NULL, label = NULL)

projr_manifest_last_change(version = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{version\_from}] character.
Starting version (e.g., "0.0.1" or "v0.0.1").
If NULL, uses the earliest version in the manifest.

\item[\code{version\_to}] character.
Ending version (e.g., "0.0.2" or "v0.0.2").
If NULL, uses the current project version.

\item[\code{label}] character.
Optional directory label to filter by.

\item[\code{version\_start}] character.
Starting version (inclusive). If NULL, uses earliest version.

\item[\code{version\_end}] character.
Ending version (inclusive). If NULL, uses current version.

\item[\code{version}] character.
Version to query. If NULL, uses current project version.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data.frame with columns:
\begin{description}

\item[label] Directory label
\item[fn] File path relative to directory
\item[change\_type] Type of change: "added", "modified", or "removed"
\item[hash\_from] File hash in version\_from (NA for added files)
\item[hash\_to] File hash in version\_to (NA for removed files)

\end{description}

Returns a 0-row data.frame if no changes found.

A data.frame with columns:
\begin{description}

\item[label] Directory label
\item[fn] File path relative to directory
\item[version\_first] First version where file appeared
\item[version\_last\_change] Last version where file was modified
\item[hash] Current file hash

\end{description}


A data.frame with columns:
\begin{description}

\item[label] Directory label
\item[version\_last\_change] Most recent version with changes
\item[n\_files] Number of files in directory at this version

\end{description}

\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Query changes between v0.0.1 and v0.0.2
projr_manifest_changes("0.0.1", "0.0.2")

# Query changes in output directory only
projr_manifest_changes("0.0.1", "0.0.2", label = "output")

# Query changes from earliest version to current
projr_manifest_changes()

## End(Not run)

## Not run: 
# Query all changes from v0.0.1 to current
projr_manifest_range("0.0.1")

# Query changes in a specific range
projr_manifest_range("0.0.1", "0.0.5")

## End(Not run)

## Not run: 
# Query last changes for current version
projr_manifest_last_change()

# Query last changes as of v0.0.5
projr_manifest_last_change("0.0.5")

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_manifest\_file\_last\_change}{Query When a Specific File Last Changed}{projr.Rul.manifest.Rul.file.Rul.last.Rul.change}
\aliasA{projr\_manifest\_file\_changed}{projr\_manifest\_file\_last\_change}{projr.Rul.manifest.Rul.file.Rul.changed}
\aliasA{projr\_manifest\_file\_first}{projr\_manifest\_file\_last\_change}{projr.Rul.manifest.Rul.file.Rul.first}
\aliasA{projr\_manifest\_file\_history}{projr\_manifest\_file\_last\_change}{projr.Rul.manifest.Rul.file.Rul.history}
%
\begin{Description}
Query when a specific file last changed in the manifest.
Returns the most recent version where the file's hash was different
from the previous version, or when it first appeared.

Check if a specific file changed between two versions.
Returns TRUE if the file's hash is different between the versions,
was added, or was removed.

Get all versions where a specific file changed or appeared.
Returns a chronological list of all versions in the manifest
where the file's hash is different from the previous version.

Get the version when a specific file first appeared in the manifest.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_manifest_file_last_change(fn, label = NULL, version_end = NULL)

projr_manifest_file_changed(
  fn,
  label = NULL,
  version_from = NULL,
  version_to = NULL
)

projr_manifest_file_history(fn, label = NULL)

projr_manifest_file_first(fn, label = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{fn}] character.
File path relative to the directory (e.g., "data.csv", "subdir/file.txt").

\item[\code{label}] character.
Directory label (e.g., "output", "raw-data").
If NULL, searches all directories for the file.

\item[\code{version\_end}] character.
End version to search up to. If NULL, uses current project version.

\item[\code{version\_from}] character.
Starting version (e.g., "0.0.1" or "v0.0.1").
If NULL, uses the earliest version in the manifest.

\item[\code{version\_to}] character.
Ending version (e.g., "0.0.2" or "v0.0.2").
If NULL, uses the current project version.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data.frame with columns:
\begin{description}

\item[label] Directory label
\item[fn] File path
\item[version\_last\_change] Version when file last changed
\item[hash] Current file hash at that version

\end{description}

Returns a 0-row data.frame if file not found.

A data.frame with columns:
\begin{description}

\item[label] Directory label
\item[fn] File path
\item[changed] Logical - TRUE if file changed
\item[change\_type] Type of change: "added", "modified", "removed", or "unchanged"
\item[hash\_from] File hash in version\_from (NA for added files)
\item[hash\_to] File hash in version\_to (NA for removed files)

\end{description}

Returns a 0-row data.frame if file not found in either version.

A data.frame with columns:
\begin{description}

\item[label] Directory label
\item[fn] File path
\item[version] Version where file changed or appeared
\item[hash] File hash at this version
\item[change\_type] Type of change: "first\_appearance", "modified", or "current"

\end{description}

Returns a 0-row data.frame if file not found.

A data.frame with columns:
\begin{description}

\item[label] Directory label
\item[fn] File path
\item[version\_first] Version when file first appeared
\item[hash] File hash at first appearance

\end{description}

Returns a 0-row data.frame if file not found.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Query when a specific file last changed
projr_manifest_file_last_change("data.csv", label = "output")

# Search all directories for a file
projr_manifest_file_last_change("report.pdf")

## End(Not run)

## Not run: 
# Check if a file changed between versions
projr_manifest_file_changed("data.csv", "output", "0.0.1", "0.0.2")

# Check against current version
projr_manifest_file_changed("data.csv", "output", "0.0.1")

## End(Not run)

## Not run: 
# Get full history for a file
projr_manifest_file_history("data.csv", label = "output")

# Search all directories
projr_manifest_file_history("config.yml")

## End(Not run)

## Not run: 
# Get when a file first appeared
projr_manifest_file_first("data.csv", label = "output")

# Search all directories
projr_manifest_file_first("README.md")

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_osf\_create\_project}{Create a new project on OSF}{projr.Rul.osf.Rul.create.Rul.project}
%
\begin{Description}
This function creates a new project on the Open Science Framework (OSF)
with the specified title, description, and visibility settings.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_osf_create_project(title, description, public)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{title}] character. Title of the project.

\item[\code{description}] character. Description of the project.

\item[\code{public}] logical.
Whether the project should be public (TRUE) or private (FALSE).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A character string containing the ID of the newly created project.
\end{Value}
%
\begin{SeeAlso}
\url{https://osf.io/} for more information about OSF.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
projr_osf_create_project(
  title = "My New Project",
  description = "This is a description of my new project.",
  public = TRUE # because open science
)

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_par\_get}{Get project parameters}{projr.Rul.par.Rul.get}
\aliasA{projr\_param\_get}{projr\_par\_get}{projr.Rul.param.Rul.get}
%
\begin{Description}
Get project parameters from \code{param} key
in \code{projr} configuration.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_par_get(..., profile = NULL)

projr_param_get(..., profile = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] character.
Sequential names to specify path in list.
For example, .param\_get("a", "b")\AsIs{\texttt{returns the value of}}projr\$param\$a\$b`.

\item[\code{profile}] character.
If \code{NULL}, then the active profile is used.
Default is \code{NULL}.
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_path\_get}{Return path}{projr.Rul.path.Rul.get}
%
\begin{Description}
Returns path to \code{projr} profile-specific directory.
Differs from \code{projr\_dir\_get} in that it does not assume
that the path is to a directory.

Will create the parent directory of the specified
path if it does not exist, and ignore it
if requested by \AsIs{\texttt{\_projr.yml}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_path_get(
  label,
  ...,
  create = TRUE,
  relative = FALSE,
  absolute = FALSE,
  safe = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{label}] character.
One of \code{"raw\_data"}, \code{"cache"},\code{"output"},
\code{"archive"} and \code{"docs"}.
Class of directory to return.
The \code{"docs"} option returns the path to
the output directory from \code{bookdown::render\_book}
(as specified in \code{"\_bookdown.yml"}),
whereas the others returns paths as specified in \code{"\_projr.yml"}.

\item[\code{...}] Specifies sub-path of directory returned.

\item[\code{create}] logical.
If \code{TRUE}, then the parent directory
is created if it does not exist and
it is ignored (or not) from \code{.gitignore}
and \code{.Rbuildignore} as specified
in \code{\_projr.yml}.
Default is \code{TRUE}.

\item[\code{relative}] logical.
If \code{TRUE}, then forces that the returned
path is relative to the project root.
Default is \code{FALSE}.

\item[\code{absolute}] logical.
If \code{TRUE}, then forces the returned path
to be absolute.
Default is \code{FALSE}.

\item[\code{safe}] logical.
If \code{TRUE}, then the output directory
is set to be \code{"<path\_to\_cache>.output"}
instead of \code{<path\_to\_output>} (as specified in \code{\_projr.yml}).
The only time that this should be set to \code{TRUE}
should be when .build\_output\AsIs{\texttt{ is being run, as otherwise "development" or test runs will add to, delete or overwrite fabciles from the previous run of .build\_output}}.
Default is \code{TRUE}.
Do not change this unless you know what you are doing.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
DETAILS
\end{Details}
%
\begin{Value}
Character.
Path to directory requested.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
if (interactive()) {
  # EXAMPLE1
}

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_path\_get\_cache\_build\_dir}{Get \code{projr} build cache directory}{projr.Rul.path.Rul.get.Rul.cache.Rul.build.Rul.dir}
\aliasA{projr\_path\_get\_cache\_build}{projr\_path\_get\_cache\_build\_dir}{projr.Rul.path.Rul.get.Rul.cache.Rul.build}
%
\begin{Description}
Get the cache directory for \code{projr} builds.
It is a sub-directory of the cache directory.
For development builds (.build\_dev\AsIs{\texttt{), this is the final directory for }}output\code{and}docs\AsIs{\texttt{ items. For output builds (.build\_output}}), this is the staging
directory. After the documents are rendered, they are copied
to their final directories.

.path\_get\_cache\_build\AsIs{\texttt{ assumes the path is to a file, whereas .path\_get\_cache\_build\_dir}} assumes the path
is to a directory.
This distinctiion is only relevant when \code{create = TRUE}, as it
determines what directory is attempted to be created.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_path_get_cache_build_dir(..., create = FALSE, profile)

projr_path_get_cache_build(..., create = FALSE, profile)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] comma-separated strings specified initially the
label (e.g. \code{"docs"} or \code{"output"}) as well as, optionally, sub-directories
(e.g. \AsIs{\texttt{"img", "}}). For example, .path\_get\_cache\_build("docs", "img")\AsIs{\texttt{returns the path to the}}img\AsIs{\texttt{directory in the}}docs` sub-directory
of the build cache directory.

\item[\code{create}] logical.
If \code{TRUE}, then the directory
is created if it does not exist.

\item[\code{profile}] character.
The name of the \code{projr} profile to use.
Default is \code{NULL}, which uses the current \code{projr} profile.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
character.
Path to the cache (sub-)directory for \code{projr} builds.
\end{Value}
%
\begin{SeeAlso}
.path\_get.path\_get\_dir
\end{SeeAlso}
\HeaderA{projr\_path\_get\_dir}{Return path to profile-specific directory}{projr.Rul.path.Rul.get.Rul.dir}
%
\begin{Description}
Returns path to \code{projr} profile-specific directory.
Also creates the directory if it does not exist, and
ignores it if requested by \AsIs{\texttt{\_projr.yml}}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_path_get_dir(
  label,
  ...,
  create = TRUE,
  relative = FALSE,
  absolute = FALSE,
  safe = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{label}] character.
One of \code{"raw"}, \code{"cache"},\code{"output"},
\code{"archive"} and \code{"docs"}.
Class of directory to return.
The \code{"docs"} option returns the path to
the output directory from \code{bookdown::render\_book}
(as specified in \code{"\_bookdown.yml"}),
whereas the others returns paths as specified in \code{"\_projr.yml"}.

\item[\code{...}] Specifies sub-directory of directory returned.
Passed to \code{file.path}.

\item[\code{create}] logical.
If \code{TRUE}, then the directory
is created if it does not exist and
it is ignored (or not) from \code{.gitignore}
and \code{.Rbuildignore} as specified
in \code{\_projr.yml}.
Default is \code{TRUE}.

\item[\code{relative}] logical.
If \code{TRUE}, then forces that the returned
path is relative to the project root.
Default is \code{FALSE}.

\item[\code{absolute}] logical.
If \code{TRUE}, then forces the returned path
to be absolute.
Default is \code{FALSE}.

\item[\code{safe}] logical.
If \code{TRUE}, then the output directory
is set to be \code{"<path\_to\_cache>.output"}
instead of \code{<path\_to\_output>} (as specified in \code{\_projr.yml}).
The only time that this should be set to \code{TRUE}
should be when .build\_output\AsIs{\texttt{ is being run, as otherwise "development" or test runs will add to, delete or overwrite fabciles from the previous run of .build\_output}}.
Default is \code{TRUE}.
Do not change this unless you know what you are doing.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Character.
Path to directory requested.
\end{Value}
\HeaderA{projr\_profile\_create}{Add projr profile file}{projr.Rul.profile.Rul.create}
%
\begin{Description}
Creates a new \code{projr} profile that can override
settings in \AsIs{\texttt{\_projr.yml}}.
If the associated file does not exists, it
creates a blank file.
The file is ignored from the R build process and, if
it is the \code{local} profile, from Git as well.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_profile_create(profile)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] character.
Name of the profile.
If not supplied, then the profile is named \code{default}
(and the file \AsIs{\texttt{\_projr.yml}} is created).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisibly returns \code{TRUE} if the file was created,
and \code{FALSE} if the file already exists.
\end{Value}
%
\begin{SeeAlso}
.profile\_create\_local.profile\_get
\end{SeeAlso}
\HeaderA{projr\_profile\_create\_local}{Create a local \code{projr} profile}{projr.Rul.profile.Rul.create.Rul.local}
%
\begin{Description}
Create a \code{projr} profile with highest precedence
(i.e. its settings overwrite any others) that is
ignored by Git.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_profile_create_local()
\end{verbatim}
\end{Usage}
%
\begin{Details}
Note that if any setting in \AsIs{\texttt{\_projr-local.yml}} is empty,
then a lower-precendence file's setting
(i.e. from \AsIs{\texttt{\_projr-<profile>.yml}} or \AsIs{\texttt{\_projr.yml}}) is used.
Empty settings are by default indicated by \code{\textasciitilde{}}.
\end{Details}
%
\begin{SeeAlso}
.profile\_create\_local.yml\_get
\end{SeeAlso}
\HeaderA{projr\_profile\_delete}{Delete a projr profile from \_projr.yml}{projr.Rul.profile.Rul.delete}
%
\begin{Description}
Deletes a \code{projr} profile from \code{\_projr.yml}
and/or its corresponding \AsIs{\texttt{\_projr-<profile>.yml}} file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_profile_delete(profile)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] character.
\code{projr} profile to delete.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{invisible(TRUE)}.
\end{Value}
\HeaderA{projr\_profile\_delete\_local}{Delete local \code{projr} settings file.}{projr.Rul.profile.Rul.delete.Rul.local}
%
\begin{Description}
Deletes \AsIs{\texttt{\_projr-local.yml}} file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_profile_delete_local()
\end{verbatim}
\end{Usage}
\HeaderA{projr\_profile\_get}{Get active projr profile}{projr.Rul.profile.Rul.get}
%
\begin{Description}
Get active \code{projr} profile(s).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_profile_get()
\end{verbatim}
\end{Usage}
%
\begin{Details}
Note that \code{local} and \code{default} are not returned, but are always active (if
they exist).
\code{local} corresponds to \AsIs{\texttt{\_projr-local.yml}} and \code{default} to \AsIs{\texttt{\_projr.yml}}.
\end{Details}
%
\begin{Value}
Character vector of length equal to number of active profiles.
\end{Value}
\HeaderA{projr\_renv\_restore}{Restore or Update renv Lockfile Packages}{projr.Rul.renv.Rul.restore}
\aliasA{projr\_renv\_restore\_and\_update}{projr\_renv\_restore}{projr.Rul.renv.Rul.restore.Rul.and.Rul.update}
\aliasA{projr\_renv\_update}{projr\_renv\_restore}{projr.Rul.renv.Rul.update}
%
\begin{Description}
Functions to manage the restoration and updating of packages specified in the \code{renv} lockfile.
\begin{itemize}

\item{} .renv\_restore()`: Restores packages from the lockfile, attempting to install the lockfile versions.
\item{} .renv\_update()`: Updates packages to their latest available versions, ignoring the lockfile versions.
\item{} .renv\_restore\_and\_update()`: First restores packages from the lockfile, then updates them to the latest versions.

\end{itemize}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_renv_restore(
  github = TRUE,
  non_github = TRUE,
  biocmanager_install = FALSE
)

projr_renv_update(
  github = TRUE,
  non_github = TRUE,
  biocmanager_install = FALSE
)

projr_renv_restore_and_update(
  github = TRUE,
  non_github = TRUE,
  biocmanager_install = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{github}] Logical. Whether to process GitHub packages. Default is \code{TRUE}.

\item[\code{non\_github}] Logical. Whether to process non-GitHub packages (CRAN and Bioconductor). Default is \code{TRUE}.

\item[\code{biocmanager\_install}] Logical.
If \code{TRUE}, Bioconductor packages will be installed using \code{BiocManager::install}; otherwise,
\code{renv::install("bioc::<package\_name>")} will be used.
Default is \code{FALSE}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Control whether to process GitHub packages, non-GitHub packages (CRAN and Bioconductor), or both using the \code{github} and \code{non\_github} arguments.
\end{Details}
%
\begin{Value}
Invisibly returns \code{TRUE} upon successful completion.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# Restore all packages
projr_renv_restore()

# Update all packages
projr_renv_update()

# Restore and then update all packages
projr_renv_restore_and_update()

# Only restore non-GitHub packages
projr_renv_restore(github = FALSE)

# Only update GitHub packages
projr_renv_update(non_github = FALSE)

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_renv\_test}{Test renv restore}{projr.Rul.renv.Rul.test}
%
\begin{Description}
Tests \code{renv::restore()} without using the cache in
a clean, temporary environment.
Automatically creates a temporary project directory, initializes \code{renv},
copies required files, disables the cache via
\code{.Rprofile}, and then performs \code{renv::restore()}.
Afterwards, it deletes the first library path where \code{renv} restored packages.

\strong{Note:}
To ensure isolation, the test runs in a directory that is completely separate
from the parent project and executes \code{Rscript} with the \code{--vanilla} option.
The \code{--vanilla} flag seems essential to prevent the project
\code{renv} settings from being affected by testing.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_renv_test(files_to_copy = NULL, delete_lib = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{files\_to\_copy}] character vector.
Paths to files to copy into the temporary directory before restoring.
Note that \code{renv.lock} is always copied.

\item[\code{delete\_lib}] Logical.
If \code{TRUE}, the restored library path is deleted after the test.
Default is \code{TRUE}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
\code{TRUE} if \code{renv::restore()} succeeds, \code{FALSE} otherwise.
\end{Value}
\HeaderA{projr\_restore\_repo}{Restore project artefact directories}{projr.Rul.restore.Rul.repo}
\aliasA{projr\_restore}{projr\_restore\_repo}{projr.Rul.restore}
\aliasA{projr\_restore\_repo\_wd}{projr\_restore\_repo}{projr.Rul.restore.Rul.repo.Rul.wd}
%
\begin{Description}
Use \code{projr\_restore()} to restore all artefacts needed for the current project.
If the project isn't available locally yet,
\code{projr\_restore\_repo()} will clone it and then restore its artefacts.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_restore_repo(
  repo,
  path = NULL,
  label = NULL,
  pos = NULL,
  type = NULL,
  title = NULL
)

projr_restore_repo_wd(
  repo,
  label = NULL,
  pos = NULL,
  type = NULL,
  title = NULL
)

projr_restore(label = NULL, pos = NULL, type = NULL, title = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{repo}] character. GitHub repository (\code{"owner/repo"} or \code{"repo"}).
(Only for repository restoration functions.)
Must be a single non-empty character string.

\item[\code{path}] character or NULL. Local path for cloning the repository. Default is \code{NULL},
creating a subdirectory named after the repo. \code{"."} restores directly into the
current directory. Must be NULL or a single non-empty character string.

\item[\code{label}] character vector or NULL. Specifies labels of artefacts to restore.
Default is \code{NULL}, restoring all \code{raw} artefacts (e.g. \code{raw-data}).
Must be NULL or a non-empty character vector with valid directory labels.

\item[\code{pos}] character vector or NULL. Specifies preferred source: \code{"source"} (directories)
or \code{"dest"} (build destinations). Default is \code{NULL}, checking both in order.
Must be NULL or one/both of \code{"source"} and \code{"dest"}.

\item[\code{type}] character or NULL. Remote type: \code{"local"}, \code{"osf"} or \code{"github"}.
Default is \code{NULL}, automatically choosing the first available remote.
Must be NULL or one of the valid remote types.

\item[\code{title}] character or NULL. Remote title as specified in \AsIs{\texttt{\_projr.yml}}.
Default is \code{NULL}, using the first available title for the selected type.
Must be NULL or a single non-empty character string.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
These functions restore artefact directories from remote sources:
\begin{itemize}

\item{} \code{projr\_restore()} restores artefacts in an existing local project without any cloning required.
Requires a \code{manifest.csv} file in the project root.
\item{} \code{projr\_restore\_repo()} clones a GitHub repository into a subdirectory (or specified path),
then restores artefacts from that repository's remote sources.
\item{} \code{projr\_restore\_repo\_wd()} clones directly into the current working directory, then restores artefacts.

\end{itemize}


\strong{Input Validation:}
All parameters are validated before execution:
\begin{itemize}

\item{} \code{label}: Must be NULL or a non-empty character vector of valid directory labels
\item{} \code{pos}: Must be NULL or contain only "source" and/or "dest"
\item{} \code{type}: Must be NULL or one of "local", "osf", or "github"
\item{} \code{title}: Must be NULL or a single character string
\item{} \code{repo}: Must be a single non-empty character string
\item{} \code{path}: Must be NULL or a single non-empty character string

\end{itemize}


\strong{Error Handling:}
The functions handle errors gracefully:
\begin{itemize}

\item{} Missing \code{manifest.csv} triggers an informative error
\item{} Invalid labels or missing remote sources result in warning messages and skipped restoration
\item{} Git clone failures are caught and reported
\item{} Errors during restoration are caught per label, allowing partial success

\end{itemize}

\end{Details}
%
\begin{Value}
Invisibly returns \code{TRUE} if all restorations are successful, \code{FALSE} otherwise.
For \code{projr\_restore()}, returns \code{FALSE} if no labels are found to restore or if any
restoration fails. For \code{projr\_restore\_repo()}, returns \code{FALSE} if cloning or
restoration fails.
\end{Value}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
  # Restore all raw artefacts in existing local project
  projr_restore()
  
  # Restore specific labels
  projr_restore(label = c("raw-data", "cache"))
  
  # Restore from specific source type
  projr_restore(type = "local", title = "archive")

  # Clone repository into subdirectory and restore artefacts
  projr_restore_repo("owner/repo")
  
  # Clone to specific path
  projr_restore_repo("owner/repo", path = "my-project")

  # Clone repository into current directory and restore artefacts
  projr_restore_repo_wd("owner/repo")

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_unignore\_manual}{Manually Unignore Files or Directories in \code{.gitignore} and \code{.Rbuildignore}}{projr.Rul.unignore.Rul.manual}
\aliasA{projr\_unignore\_manual\_dir}{projr\_unignore\_manual}{projr.Rul.unignore.Rul.manual.Rul.dir}
\aliasA{projr\_unignore\_manual\_dir\_git}{projr\_unignore\_manual}{projr.Rul.unignore.Rul.manual.Rul.dir.Rul.git}
\aliasA{projr\_unignore\_manual\_dir\_rbuild}{projr\_unignore\_manual}{projr.Rul.unignore.Rul.manual.Rul.dir.Rul.rbuild}
\aliasA{projr\_unignore\_manual\_file}{projr\_unignore\_manual}{projr.Rul.unignore.Rul.manual.Rul.file}
\aliasA{projr\_unignore\_manual\_file\_git}{projr\_unignore\_manual}{projr.Rul.unignore.Rul.manual.Rul.file.Rul.git}
\aliasA{projr\_unignore\_manual\_file\_rbuild}{projr\_unignore\_manual}{projr.Rul.unignore.Rul.manual.Rul.file.Rul.rbuild}
%
\begin{Description}
These functions allow manual addition of files and directories to the
\code{.gitignore} and \code{.Rbuildignore} files \strong{after} the projr-managed block,
thereby forcing them to be \emph{not} ignored.
\begin{itemize}

\item{} .unignore\_manual\AsIs{\texttt{: General function to unignore both files and directories in both }}.gitignore\code{and}.Rbuildignore`. If a path does not
exist, it is treated as a file.
\item{} .unignore\_manual\_dir\AsIs{\texttt{: Specifically unignores directories in both }}.gitignore\code{and}.Rbuildignore`.
\item{} .unignore\_manual\_file\AsIs{\texttt{: Specifically unignores files in both }}.gitignore\code{and}.Rbuildignore`.
\item{} .unignore\_manual\_dir\_git\AsIs{\texttt{ and .unignore\_manual\_file\_git}}: Add
directories or files explicitly (with a \code{!} prefix) to \code{.gitignore}.
\item{} .unignore\_manual\_dir\_rbuild\AsIs{\texttt{ and .unignore\_manual\_file\_rbuild}}:
Add directories or files explicitly (with a \code{!} prefix) to \code{.Rbuildignore}.

\end{itemize}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_unignore_manual(unignore)

projr_unignore_manual_dir(unignore)

projr_unignore_manual_file(unignore)

projr_unignore_manual_file_git(unignore)

projr_unignore_manual_dir_git(unignore)

projr_unignore_manual_file_rbuild(unignore)

projr_unignore_manual_dir_rbuild(unignore)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{unignore}] A character vector of file or directory paths to be unignored.
Paths must be valid non-empty strings.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
These functions provide fine-grained control for cases where users want to
\emph{undo} any ignoring behavior for specific paths permanently. They do not
interact with the automated ignore management system of \code{projr}.
\begin{itemize}

\item{} Non-existent paths provided to .unignore\_manual` are assumed to be files.
\item{} For \code{.gitignore}, unignored directories are automatically appended with
\AsIs{\texttt{/**}} if missing, then prepended with \code{!}, ensuring proper Git \emph{unignore}
syntax.
\item{} For \code{.Rbuildignore}, paths are converted to regular expressions using
\code{glob2rx()}, and then prepended with \code{!} for compatibility with R's build
tools.

\end{itemize}

\end{Details}
%
\begin{Value}
Invisibly returns \code{TRUE} if the operation succeeds, or \code{FALSE} if the input
contains invalid (empty) paths.
\end{Value}
%
\begin{SeeAlso}
.ignore\_manual\AsIs{\texttt{ for manually ignoring paths, and .ignore\_auto}} for
dynamically managed ignore entries.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
# Manually unignore files and directories
projr_unignore_manual(c("output", "tempfile.log"))

# Specifically unignore directories
projr_unignore_manual_dir("data")

# Specifically unignore files
projr_unignore_manual_file("README.md")

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_use\_data}{\code{projr} drop-in replacement for usethis::use\_data}{projr.Rul.use.Rul.data}
%
\begin{Description}
usethis::use\_data always saves data to \AsIs{\texttt{data/}}, which
conflicts with the temporary directories used by .build\_dev`
and makes it difficult to restore after failed output builds.

.use\_data\AsIs{\texttt{is a drop-in replacement for}}usethis::use\_data\AsIs{\texttt{, which saves data to the temporary directory when }}safe = TRUE`.
This makes it easier to restore the project after a failed output build.

The only other difference is that .use\_data\AsIs{\texttt{invisibly returns the path to the saved data file, whereas}}usethis::use\_data\code{returns}TRUE`.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_use_data(
  ...,
  internal = FALSE,
  overwrite = FALSE,
  compress = "bzip2",
  version = 2,
  ascii = FALSE,
  safe = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{...}] Unquoted names of existing objects to save.

\item[\code{internal}] If \code{FALSE}, saves each object in its own \code{.rda}
file in the \AsIs{\texttt{data/}} directory. These data files bypass the usual
export mechanism and are available whenever the package is loaded
(or via \code{\LinkA{data()}{data}} if \code{LazyData} is not true).

If \code{TRUE}, stores all objects in a single \code{R/sysdata.rda} file.
Objects in this file follow the usual export rules. Note that this means
they will be exported if you are using the common \code{exportPattern()}
rule which exports all objects except for those that start with \code{.}.

\item[\code{overwrite}] By default, .use\_data()\AsIs{\texttt{will not overwrite existing files. If you really want to do so, set this to}}TRUE`.

\item[\code{compress}] Choose the type of compression used by \code{\LinkA{save()}{save}}.
Should be one of "gzip", "bzip2", or "xz".

\item[\code{version}] The serialization format version to use. The default, 2, was
the default format from R 1.4.0 to 3.5.3. Version 3 became the default from
R 3.6.0 and can only be read by R versions 3.5.0 and higher.

\item[\code{ascii}] if \code{TRUE}, an ASCII representation of the data is
written.  The default value of \code{ascii} is \code{FALSE} which
leads to a binary file being written.  If \code{NA} and
\code{version >= 2}, a different ASCII representation is used which
writes double/complex numbers as binary fractions.

\item[\code{safe}] logical.
Whether to save data to a temporary directory
(in \AsIs{\texttt{<cache>/"projr"/v<version>/data/}})
or "data/".
Default is the temporary directory (TRUE).
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Taken directly from the documentation for the original
\code{usethis} function, and adjusted slightly.
\end{Details}
%
\begin{SeeAlso}
The \Rhref{https://r-pkgs.org/data.html}{data chapter} of \Rhref{https://r-pkgs.org}{R Packages}.
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
x <- 1:10
y <- 1:100

projr_use_data(x, y) # For external use
projr_use_data(x, y, internal = TRUE) # For internal use

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_version\_get}{Returns project version}{projr.Rul.version.Rul.get}
%
\begin{Description}
Returns project version
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_version_get()
\end{verbatim}
\end{Usage}
%
\begin{Value}
Character.
\end{Value}
\HeaderA{projr\_version\_set}{Set Project Version}{projr.Rul.version.Rul.set}
%
\begin{Description}
Sets the project version manually in the \code{DESCRIPTION} file and optionally in a \code{VERSION} file.
This is useful in cases where you need to increment the version manually, for example,
if a collaborator has pushed changes and you want to manually set your version before merging.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_version_set(version, only_if_exists = TRUE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{version}] A character string specifying the version to set.
It may include a development component (e.g., "1.2.3-dev") or just the stable version (e.g., "1.2.3").

\item[\code{only\_if\_exists}] A logical flag indicating whether to update the \code{VERSION} file
only if it already exists (\code{TRUE}) or to create it if it doesn't exist (\code{FALSE}).
Defaults to \code{TRUE}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisibly returns \code{TRUE} if successful.
\end{Value}
\HeaderA{projr\_yml\_check}{Check active \code{projr} settings.}{projr.Rul.yml.Rul.check}
%
\begin{Description}
Checks correctness of active \code{projr} settings.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_check(profile = NULL)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] character().
Profile whose file needs to be checked.
If not supplied, then the merged profile is used.
Default is NULL.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Returns \code{TRUE} if all checks pass.
Otherwise throws an error.
\end{Value}
\HeaderA{projr\_yml\_cite\_set}{Set citation options}{projr.Rul.yml.Rul.cite.Rul.set}
\aliasA{projr\_yml\_cite\_set\_default}{projr\_yml\_cite\_set}{projr.Rul.yml.Rul.cite.Rul.set.Rul.default}
%
\begin{Description}
.yml\_cite\_set\AsIs{\texttt{sets the citation options in}}\_projr.yml`.

The options are:
\begin{itemize}

\item{} codemeta: whether to generate a codemeta.json file.
\item{} cff:
whether to generate a CITATION.cff file.
Indexable by GitHub and Zenodo.
\item{} inst-citation:
whether to generate a CITATION file in the inst/ directory.
If the project is installed as an \code{R} package,
then citation data can be generated by
\AsIs{\texttt{citation(package = <project\_name>)}}.

\end{itemize}

The default is to leave all the settings unchanged.

If these settings are not setting in \AsIs{\texttt{\_projr.yml}},
then the default is to generate a codemeta.json file,
a CITATION.cff file and a CITATION file in the inst/ directory.

.yml\_cite\_set\_default\AsIs{\texttt{ sets all citation options to default (}}TRUE`).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_cite_set(
  all = NULL,
  codemeta = NULL,
  cff = NULL,
  inst_citation = NULL,
  simplify_identical = TRUE,
  simplify_default = TRUE,
  profile = "default"
)

projr_yml_cite_set_default(
  profile = "default",
  simplify_identical = TRUE,
  simplify_default = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{all}] logical.
Whether to set all the options
to \code{TRUE} or \code{FALSE}.
If \code{NULL}, then \code{codemeta}, \code{cff} and \code{inst\_citation} are used.
Default is \code{NULL}.

\item[\code{codemeta}] logical.
Whether to generate a codemeta.json file.
If \code{NULL}, then setting is not changed.

\item[\code{cff}] logical.
Whether to generate a CITATION.cff file.
If \code{NULL}, then setting is not changed.

\item[\code{inst\_citation}] logical.
Whether to generate a CITATION file in the inst/ directory.
If \code{NULL}, then setting is not changed.

\item[\code{simplify\_identical}] logical.
If \code{TRUE}, then if all the settings are the same
then only \code{cite: TRUE} or \code{cite: FALSE} is written to \AsIs{\texttt{\_projr.yml}}.
Default is \code{TRUE}.

\item[\code{simplify\_default}] logical.
If \code{TRUE}, then if all the settings are the same
and equl to the default (\code{TRUE}),
then the settings are not recorded in the \code{projr}
configuration file (as the default will be equal to it).

\item[\code{profile}] character.
The profile to write to.
Default is "default", in which case it writes to \AsIs{\texttt{\_projr.yml}}.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# set all to TRUE
projr_yml_cite_set(all = TRUE)

# set all to FALSE
projr_yml_cite_set(all = FALSE)

# set only cff to FALSE
projr_yml_cite_set(cff = FALSE)

# revert to defaults
projr_yml_cite_set()

## End(Not run)

\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_yml\_dest\_add\_github}{Add a GitHub release as a destination}{projr.Rul.yml.Rul.dest.Rul.add.Rul.github}
%
\begin{Description}
Add a GitHub release as a destination
to a \_projr.yml file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_dest_add_github(
  title,
  content,
  structure = NULL,
  overwrite = TRUE,
  send_cue = NULL,
  send_strategy = NULL,
  send_inspect = NULL,
  profile = "default"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{title}] character.
Title of the GitHub release.
Can use title as \AsIs{\texttt{@version}},
in which case the release will be entitled
the version of the project at the time.
If not supplied, then will
automatically be generated from \code{content}.

\item[\code{content}] character vector.
Labels of directories to include in the upload.
Options are the labels of directories
in the active \code{projr} configuration,
as well as "docs", "data" and "code".
"docs" means the directory where the documents are rendered to,
"data" means the files in the \code{"data"} directory,
and "code" means all files tracked by the Git repository.

\item[\code{structure}] "latest" or "version".
Structure of the remote.
If "latest", then \code{path} simply contains
the latest versions of the contents.
If "version", then \code{path} will contain
a directory for each version.
If not supplied, will be \code{version}.

\item[\code{overwrite}] logical.
Whether to rewrite an existing entry of the same
title in the specified \code{projr} configuration file.
Default is TRUE.

\item[\code{send\_cue}] "always", "if-change" or "never".
Only relevant if \code{structure} is \code{archive}
and \code{send\_strategy} is \code{sync-diff} or \code{sync-purge}.
If \code{always}, then a new remote is created
every time, even if there is no change from the previous
build.
For example, if the contents of \code{raw-data} are the same
between builds \code{v0.0.1} and \code{v0.0.2}, then
a local remote would have folders \code{raw-data/v0.0.1}
and \code{raw-data/v0.0.2}.
If \AsIs{\texttt{if-change}}, then a new remote is created
only if there is a change from the previous build.
In the example above, a local remote would
only have the folder \code{raw-data/v0.0.1}.
If \code{never}, then a new remote is never created.

\item[\code{send\_strategy}] "upload-all", "upload-missing",
"sync-purge" and "sync-diff".
How to synchronise to the remote.
If \code{upload-all}, then all files are uploaded.
If \code{upload-missing}, then only missing files are uploaded.
If \code{sync-purge}, then all files on the remote
are deleted before uploading all local files.
If \code{sync-diff}, then files
that have changed or been added locally are uploaded to the remote,
and files that have been removed locally are removed from the remote.
If not set, then "sync-diff" will be used.

\item[\code{send\_inspect}] "manifest" , "file" or "none".
What to look at to find what are the
files on the remote, and their versions.
If \code{manifest}, then the manifest on the remote is used.
If \code{file}, then the files on the remote are downloaded
and their versions are determined.
If \code{none}, then no inspection is done (the remote
is typically treated as "empty" in that case).
If not set, then defaults to \code{"manifest"}.

\item[\code{profile}] character.
Profile to write the settings to.
If "default", then written to \AsIs{\texttt{\_projr.yml}},
otherwise written to \AsIs{\texttt{\_projr-<profile>.yml}}.
The default is "default".
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_yml\_dest\_add\_local}{Add a local directory as a destination}{projr.Rul.yml.Rul.dest.Rul.add.Rul.local}
%
\begin{Description}
Add a local directory as a destination
to a \_projr.yml file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_dest_add_local(
  title,
  content,
  path,
  structure = NULL,
  overwrite = TRUE,
  send_cue = NULL,
  send_strategy = NULL,
  send_inspect = NULL,
  profile = "default"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{title}] character.
The name of the directory.
Has no effect besides helping structure \AsIs{\texttt{\_projr.yml}}.
If not supplied, will be made equal to \code{content}.

\item[\code{content}] character vector.
Labels of directories to include in the upload.
Options are the labels of directories
in the active \code{projr} configuration,
as well as "docs", "data" and "code".
"docs" means the directory where the documents are rendered to,
"data" means the files in the \code{"data"} directory,
and "code" means all files tracked by the Git repository.

\item[\code{path}] character.
Path to the directory.
If a relative path is given, then it is taken as
relative to the project home directory.
Must be supplied.

\item[\code{structure}] "latest" or "version".
Structure of the remote.
If "latest", then \code{path} simply contains
the latest versions of the contents.
If "version", then \code{path} will contain
a directory for each version.
If not supplied, will be \code{version}.

\item[\code{overwrite}] logical.
Whether to rewrite an existing entry of the same
title in the specified \code{projr} configuration file.
Default is TRUE.

\item[\code{send\_cue}] "always", "if-change" or "never".
Only relevant if \code{structure} is \code{archive}
and \code{send\_strategy} is \code{sync-diff} or \code{sync-purge}.
If \code{always}, then a new remote is created
every time, even if there is no change from the previous
build.
For example, if the contents of \code{raw-data} are the same
between builds \code{v0.0.1} and \code{v0.0.2}, then
a local remote would have folders \code{raw-data/v0.0.1}
and \code{raw-data/v0.0.2}.
If \AsIs{\texttt{if-change}}, then a new remote is created
only if there is a change from the previous build.
In the example above, a local remote would
only have the folder \code{raw-data/v0.0.1}.
If \code{never}, then a new remote is never created.

\item[\code{send\_strategy}] "upload-all", "upload-missing",
"sync-purge" and "sync-diff".
How to synchronise to the remote.
If \code{upload-all}, then all files are uploaded.
If \code{upload-missing}, then only missing files are uploaded.
If \code{sync-purge}, then all files on the remote
are deleted before uploading all local files.
If \code{sync-diff}, then files
that have changed or been added locally are uploaded to the remote,
and files that have been removed locally are removed from the remote.
If not set, then "sync-diff" will be used.

\item[\code{send\_inspect}] "manifest" , "file" or "none".
What to look at to find what are the
files on the remote, and their versions.
If \code{manifest}, then the manifest on the remote is used.
If \code{file}, then the files on the remote are downloaded
and their versions are determined.
If \code{none}, then no inspection is done (the remote
is typically treated as "empty" in that case).
If not set, then defaults to \code{"manifest"}.

\item[\code{profile}] character.
Profile to write the settings to.
If "default", then written to \AsIs{\texttt{\_projr.yml}},
otherwise written to \AsIs{\texttt{\_projr-<profile>.yml}}.
The default is "default".
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_yml\_dest\_add\_osf}{Add an OSF node as a destination}{projr.Rul.yml.Rul.dest.Rul.add.Rul.osf}
\aliasA{projr\_yml\_dest\_add\_osf\_comp}{projr\_yml\_dest\_add\_osf}{projr.Rul.yml.Rul.dest.Rul.add.Rul.osf.Rul.comp}
\aliasA{projr\_yml\_dest\_add\_osf\_proj}{projr\_yml\_dest\_add\_osf}{projr.Rul.yml.Rul.dest.Rul.add.Rul.osf.Rul.proj}
%
\begin{Description}
Add an OSF node (project or component)
as a destination to a \_projr.yml file.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_dest_add_osf(
  title,
  content,
  path = NULL,
  structure = NULL,
  overwrite = FALSE,
  public = FALSE,
  category = NULL,
  description = NULL,
  id = NULL,
  id_parent = NULL,
  send_cue = NULL,
  send_strategy = NULL,
  send_inspect = NULL,
  profile = "default"
)

projr_yml_dest_add_osf_proj(
  title,
  description = NULL,
  content = NULL,
  public = FALSE,
  id = NULL
)

projr_yml_dest_add_osf_comp(
  title,
  description = NULL,
  content = NULL,
  public = FALSE,
  category = NULL,
  id_parent = NULL,
  id = NULL
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{title}] character.
Title of the OSF node.
For GitHub releases, can use title as \AsIs{\texttt{@version}},
Note that this implies that a new tag will be created with each
new version, so do not use with large files.
If not supplied, then will
automatically be generated from \code{content}.

\item[\code{content}] character vector.
Labels of directories to include in the upload.
Options are the labels of directories
in the active \code{projr} configuration,
as well as "docs", "data" and "code".
"docs" means the directory where the documents are rendered to,
"data" means the files in the \code{"data"} directory,
and "code" means all files tracked by the Git repository.

\item[\code{path}] character.
Path to the directory on the OSF node.

\item[\code{structure}] "latest" or "version".
Structure of the remote.
If "latest", then \code{path} simply contains
the latest versions of the contents.
If "version", then \code{path} will contain
a directory for each version.
If not supplied, will be \code{version}.

\item[\code{overwrite}] logical.
Whether to rewrite an existing entry of the same
title in the specified \code{projr} configuration file.
Default is TRUE.

\item[\code{public}] logical.
Whether the OSF node is public.
Default is \code{FALSE}.

\item[\code{category}] character. The category of the project or component.
The following are valid options: \code{"project"}, \code{"analysis"},
\code{"communication"}, \code{"data"}, \code{"hypothesis"}, \code{"instrumentation"},
\code{"methods and measures"}, \code{"procedure"}, \code{"project"}, \code{"software"} and other
\code{"other"}. Default is \code{NULL.}

\item[\code{description}] character.
Description of the OSF node.
Default is \code{NULL}.

\item[\code{id}] character. The id of the project or component. Must be five
characters. Default is \code{NULL}.

\item[\code{id\_parent}] character. The id of the parent project or component.
Must be five characters. Default is \code{NULL}.

\item[\code{send\_cue}] "always", "if-change" or "never".
Only relevant if \code{structure} is \code{archive}
and \code{send\_strategy} is \code{sync-diff} or \code{sync-purge}.
If \code{always}, then a new remote is created
every time, even if there is no change from the previous
build.
For example, if the contents of \code{raw-data} are the same
between builds \code{v0.0.1} and \code{v0.0.2}, then
a local remote would have folders \code{raw-data/v0.0.1}
and \code{raw-data/v0.0.2}.
If \AsIs{\texttt{if-change}}, then a new remote is created
only if there is a change from the previous build.
In the example above, a local remote would
only have the folder \code{raw-data/v0.0.1}.
If \code{never}, then a new remote is never created.

\item[\code{send\_strategy}] "upload-all", "upload-missing",
"sync-purge" and "sync-diff".
How to synchronise to the remote.
If \code{upload-all}, then all files are uploaded.
If \code{upload-missing}, then only missing files are uploaded.
If \code{sync-purge}, then all files on the remote
are deleted before uploading all local files.
If \code{sync-diff}, then files
that have changed or been added locally are uploaded to the remote,
and files that have been removed locally are removed from the remote.
If not set, then "sync-diff" will be used.

\item[\code{send\_inspect}] "manifest" , "file" or "none".
What to look at to find what are the
files on the remote, and their versions.
If \code{manifest}, then the manifest on the remote is used.
If \code{file}, then the files on the remote are downloaded
and their versions are determined.
If \code{none}, then no inspection is done (the remote
is typically treated as "empty" in that case).
If not set, then defaults to \code{"manifest"}.

\item[\code{profile}] character.
Profile to write the settings to.
If "default", then written to \AsIs{\texttt{\_projr.yml}},
otherwise written to \AsIs{\texttt{\_projr-<profile>.yml}}.
The default is "default".
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_yml\_get}{Get active \code{projr} settings and checks for validity}{projr.Rul.yml.Rul.get}
%
\begin{Description}
Gets active \code{projr} settings, which merges settings and resolves conflicts
between local (\AsIs{\texttt{\_projr-local.yml}}), profile (\AsIs{\texttt{\_projr-<projr>.yml}} or as
- keys in \AsIs{\texttt{\_projr.yml}})
and default (\AsIs{\texttt{\_projr.yml}}) settings.
Where there are conflicts, local settings has highest precedence
(i.e. are always preferred) and default settings have lowest precedence
(i.e. are never preferred).

Note that an error is thrown if the active settings
are invalid.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_get(profile = NULL, check = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] character.
\code{projr} profile to use.
If \code{NULL}, then the active profile is used.
Default is \code{NULL}.

\item[\code{check}] logical.
Whether to check the validity of the settings.
Default is \code{FALSE}.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A named list, if the settings are valid.
\end{Value}
%
\begin{SeeAlso}
.yml\_get\_unchecked.yml\_check
\end{SeeAlso}
\HeaderA{projr\_yml\_git\_set}{Set Git options}{projr.Rul.yml.Rul.git.Rul.set}
\aliasA{projr\_yml\_git\_set\_default}{projr\_yml\_git\_set}{projr.Rul.yml.Rul.git.Rul.set.Rul.default}
%
\begin{Description}
.yml\_git\_set` sets Git options for the project.

The options are:
\begin{itemize}

\item{} commit: whether to commit changes automatically upon
project builds.
\item{} add\_untracked: whether to add untracked files automatically upon
project builds.
\item{} push: whether to push changes automatically upon
project builds.

\end{itemize}

The default is to leave all the settings unchanged.

If these settings are not setting in \AsIs{\texttt{\_projr.yml}},
then the default is to commit, add untracked files and push.

.yml\_git\_set\_default\AsIs{\texttt{ sets all Git options to default (}}TRUE`).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_git_set(
  all = NULL,
  commit = NULL,
  add_untracked = NULL,
  push = NULL,
  simplify_identical = TRUE,
  simplify_default = TRUE,
  profile = "default"
)

projr_yml_git_set_default(
  profile = "default",
  simplify_identical = TRUE,
  simplify_default = TRUE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{all}] logical.
Whether to set all the options
to \code{TRUE} or \code{FALSE}.
If \code{NULL}, then \code{commit}, \code{add\_untracked} and \code{push} are used.
Default is \code{NULL}.

\item[\code{commit}] logical.
Whether to commit changes automatically upon
project builds.
If \code{NULL}, then setting is not changed.
Default is \code{NULL}.

\item[\code{add\_untracked}] logical.
Whether to add untracked files automatically upon
project builds.
If \code{NULL}, then setting is not changed.
Default is \code{NULL}.

\item[\code{push}] logical.
Whether to push changes automatically upon
project builds.
If \code{NULL}, then setting is not changed.
Default is \code{NULL}.

\item[\code{simplify\_identical}] logical.
If \code{TRUE}, then if all the settings are the same
(for \code{commit}, \code{push} and \code{add\_untracked}),
then only \code{git: TRUE} or \code{git: FALSE} is written to \AsIs{\texttt{\_projr.yml}}.
Default is \code{TRUE}.

\item[\code{simplify\_default}] logical.
If \code{TRUE}, then if the settings are the same as the default
(which is TRUE),
then the settings are removed from \AsIs{\texttt{\_projr.yml}}.
Default is \code{TRUE}.

\item[\code{profile}] character.
Profile to add the script to.
If \AsIs{\texttt{"default"`` (the default), the script is added to the default profile, which is }}\_projr.yml\AsIs{\texttt{. If }}NULL\AsIs{\texttt{, then the active profile is used (i.e the merge of }}\_projr-local.yml\AsIs{\texttt{, }}\_projr-.yml\code{and}\_projr.yml\AsIs{\texttt{) and written to }}\_projr.yml\AsIs{\texttt{. If another character vector, then the corresponding profile is used and written to }}\_projr-.yml`.
\end{ldescription}
\end{Arguments}
%
\begin{Examples}
\begin{ExampleCode}
## Not run: 
# set all to TRUE
projr_yml_git_set(all = TRUE)

# set all to FALSE
projr_yml_git_set(all = FALSE)

# set only add_untracked to FALSE
projr_yml_git_set(add_untracked = FALSE)

# revert to defaults
projr_yml_git_set_default()

## End(Not run)
\end{ExampleCode}
\end{Examples}
\HeaderA{projr\_yml\_hooks\_add}{Build hook-related functions}{projr.Rul.yml.Rul.hooks.Rul.add}
\aliasA{projr\_yml\_hooks\_add\_post}{projr\_yml\_hooks\_add}{projr.Rul.yml.Rul.hooks.Rul.add.Rul.post}
\aliasA{projr\_yml\_hooks\_add\_pre}{projr\_yml\_hooks\_add}{projr.Rul.yml.Rul.hooks.Rul.add.Rul.pre}
\aliasA{projr\_yml\_hooks\_rm\_all}{projr\_yml\_hooks\_add}{projr.Rul.yml.Rul.hooks.Rul.rm.Rul.all}
%
\begin{Description}
Convenience functions to add or remove hooks
to run before or after the build.
\begin{itemize}

\item{} \code{projr\_yml\_hooks\_add}: Add hook script(s) to run before or after the build.
\item{} \code{projr\_yml\_hooks\_rm\_all}: Remove all hooks.
\item{} \code{projr\_yml\_hooks\_add\_pre}: Add hook(s) to run before the build.
\item{} \code{projr\_yml\_hooks\_add\_post}: Add hook(s) to run after the build.

\end{itemize}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_hooks_add(path, stage, overwrite = TRUE, profile = "default")

projr_yml_hooks_rm_all(profile = "default")

projr_yml_hooks_add_pre(path, overwrite = TRUE, profile = "default")

projr_yml_hooks_add_post(path, overwrite = TRUE, profile = "default")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] character vector.
Path(s) to hook scripts, relative to project root (if not absolute).

\item[\code{stage}] "pre", "post", or "both".
Whether to run the hook before the build ("pre"),
after the build ("post"), or in both stages ("both").
Hooks with stage "pre" are stored under \code{build.hooks.pre},
hooks with stage "post" are stored under \code{build.hooks.post},
and hooks with stage "both" are stored under \code{build.hooks.both}.

\item[\code{overwrite}] logical.
Whether to overwrite existing hooks or append to them.
Default is \code{TRUE}.

\item[\code{profile}] character.
Profile to add the hook to.
If \code{"default"} (the default),
the hook is added to the default profile,
which is \code{\_projr.yml}.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Within a stage (pre- or post-build), hooks
are run in the order specified in \code{\_projr.yml}.
They are not run in the same environment as the
build process.
The pre-build hooks are run immediately after
bumping the project version (if that is done) and immediately
before committing the present state of the code to Git.
The post-build hooks are run immediately after
committing the present state of the code to Git,
and before distributing project artifacts to the remotes.

Hooks are stored as simple character vectors in the YAML:
\begin{alltt}
build:
  hooks:
    pre: ["pre-hook.R"]
    post: ["post-hook.R"]
    both: ["both-hook.R"]
\end{alltt}

\end{Details}
\HeaderA{projr\_yml\_par\_add}{Add the \code{parameters} key}{projr.Rul.yml.Rul.par.Rul.add}
%
\begin{Description}
Add the \code{parameters} key to the \code{projr} configuration.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_par_add(profile = "default")
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{profile}] character.
If \code{NULL}, then the default profile is used.
Default is \code{"default"}.
\end{ldescription}
\end{Arguments}
\HeaderA{projr\_yml\_script\_add}{Build script-related functions}{projr.Rul.yml.Rul.script.Rul.add}
\aliasA{projr\_yml\_script\_add\_post}{projr\_yml\_script\_add}{projr.Rul.yml.Rul.script.Rul.add.Rul.post}
\aliasA{projr\_yml\_script\_add\_pre}{projr\_yml\_script\_add}{projr.Rul.yml.Rul.script.Rul.add.Rul.pre}
\aliasA{projr\_yml\_script\_rm}{projr\_yml\_script\_add}{projr.Rul.yml.Rul.script.Rul.rm}
\aliasA{projr\_yml\_script\_rm\_all}{projr\_yml\_script\_add}{projr.Rul.yml.Rul.script.Rul.rm.Rul.all}
%
\begin{Description}
Convenience functions to add or remove scripts
to run before or after the build.
\begin{itemize}

\item{} .yml\_script\_add`: Add a script to run before or after the build.
\item{} .yml\_script\_rm`: Remove scripts to run.

\end{itemize}


.yml\_script\_add\_pre\AsIs{\texttt{ and .yml\_script\_add\_post}}
are wrappers around .yml\_script\_add\AsIs{\texttt{that set the}}stage\AsIs{\texttt{argument to}}"pre"\code{or}"post"\AsIs{\texttt{, respectively. .yml\_script\_rm\_all}} removes all scripts.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
projr_yml_script_add(
  path,
  title,
  stage,
  cue = NULL,
  overwrite = TRUE,
  profile = "default"
)

projr_yml_script_rm(title, path = NULL, profile = "default")

projr_yml_script_rm_all(profile = "default")

projr_yml_script_add_pre(
  path,
  title,
  cue = NULL,
  overwrite = TRUE,
  profile = "default"
)

projr_yml_script_add_post(
  path,
  title,
  cue = NULL,
  overwrite = TRUE,
  profile = "default"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{path}] character vector.
Path(s) to scripts, relative to project root (if not absolute).

\item[\code{title}] character.
Title for set of scripts.
Initial and trailing spaces are removed, and
the middle spaces are converted to dashes.
For example, \code{" a b "} is converted to
\code{"a-b"}. `

\item[\code{stage}] "pre" or "post".
Whether to run the script before or after the build.

\item[\code{cue}] "build", "dev", "patch", "minor" or "major".
Which minimum build level triggers the scripts.
"build" and "dev" are equivalent, and
always trigger the scripts.

\item[\code{overwrite}] logical.
Whether to overwrite any script settings
of the same title in the \code{projr}
configuration file.
If \code{FALSE} and there already exists
a key under \code{build/script} with the name
\code{title}, an error is thrown.
Default is \code{TRUE}.

\item[\code{profile}] character.
Profile to add the script to.
If \AsIs{\texttt{"default"`` (the default), the script is added to the default profile, which is }}\_projr.yml`.
\end{ldescription}
\end{Arguments}
%
\begin{Details}
Within a stage (pre- or post-build), scripts
are run in the order set in \AsIs{\texttt{\_projr.yml}}.
They are not run in the same environment as the
build process.
The pre-build scripts are run immediately after
bumping the project version (if that is done) and immediately
before committing the present state of the code to Git.
The post-build scripts are run immediately after
committing the present state of the code to Git,
and before distributing project artefacts to the remotes.
\end{Details}
\printindex{}
\end{document}
