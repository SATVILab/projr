---
title: "Restoring Artifacts"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Restoring Artifacts}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(projr)
```

# Introduction

This vignette provides a comprehensive guide to restoring project artifacts in projr. Artifact restoration allows you to:

- Set up a project on a new machine
- Recover data from archived versions
- Share reproducible research with collaborators
- Restore specific components without cloning everything

## What Are Artifacts?

In projr, **artifacts** are the versioned components of your project:

- **Raw data** (`raw-data`): Source data files
- **Cache** (`cache`): Intermediate computation results
- **Output** (`output`): Final analysis outputs (figures, tables)
- **Docs** (`docs`): Rendered documents (HTML, PDF)
- **Code** (`code`): All Git-tracked source files

These artifacts are archived to remote destinations during builds and can be restored later.

## When to Restore Artifacts

Common scenarios:

1. **New machine setup**: Clone repository and restore data to start working
2. **Collaboration**: Team member needs project data to reproduce analysis
3. **Disaster recovery**: Lost local files need to be recovered from archives
4. **Version comparison**: Restore specific version to compare results
5. **Reproducibility**: Restore exact inputs that created published outputs

---

# Restoration Workflows

projr provides three main restoration functions:

1. `projr_restore_repo()`: Clone repository and restore artifacts (most common)
2. `projr_restore_repo_wd()`: Restore into current directory
3. `projr_restore()`: Restore artifacts in existing local project

## Workflow 1: Clone and Restore (Most Common)

**Scenario**: You want to set up a project on a new machine.

```{r eval=FALSE}
# Clone repository into subdirectory and restore raw data
projr_restore_repo("owner/repo")

# This will:
# 1. Clone github.com/owner/repo into ./repo/
# 2. Read _projr.yml to find configured remotes
# 3. Restore all raw artifacts (raw-data, cache, etc.)
# 4. You're ready to work!
```

**With custom path:**

```{r eval=FALSE}
# Clone to specific directory
projr_restore_repo("owner/repo", path = "~/projects/my-analysis")

# Clone into current directory (use with caution!)
projr_restore_repo("owner/repo", path = ".")
```

**Output:**

```
✔ Cloning repository owner/repo
✔ Restoring raw-data from github (release: raw-data-v0.1.0)
✔ Restoring cache from local (path: ~/archive/cache)
✔ All artifacts restored successfully
```

## Workflow 2: Restore into Current Directory

**Scenario**: You've already navigated to where you want the project.

```{r eval=FALSE}
# From within target directory:
projr_restore_repo_wd("owner/repo")

# This clones directly into current directory (no subdirectory created)
```

**Warning**: This will create files in your current directory. Ensure you're in the right location!

## Workflow 3: Restore in Existing Project

**Scenario**: You already have the repository cloned and just need to update artifacts.

```{r eval=FALSE}
# Navigate to project directory first
setwd("~/projects/my-analysis")

# Restore all raw artifacts
projr_restore()

# Restore specific artifacts
projr_restore(label = "raw-data")
projr_restore(label = c("raw-data", "cache"))
```

---

# Understanding Restoration Sources

## Source Types

projr checks remote sources in this order:

1. **GitHub Releases**: If configured in `_projr.yml`
2. **OSF**: If configured in `_projr.yml`
3. **Local directories**: If configured in `_projr.yml`

The first available source is used for each artifact.

## Source Configuration

Your `_projr.yml` file specifies where artifacts can be restored from:

```yaml
build:
  github:
    raw-data-release:
      title: "raw-data-@version"
      content: [raw-data]
  local:
    cache-backup:
      title: "cache-backup"
      content: [cache]
      path: "~/archive/cache"
```

This configuration tells projr:

- Restore `raw-data` from GitHub releases
- Restore `cache` from local directory at `~/archive/cache`

## Checking Available Sources

```{r eval=FALSE}
# View your project's remote configuration
projr_yml_get()$build

# Check what will be restored
projr_restore()  # Shows what would be restored
```

---

# Restoration Parameters

## Label: Which Artifacts to Restore

The `label` parameter controls which artifacts are restored:

**Restore all raw artifacts (default):**

```{r eval=FALSE}
projr_restore()
# Restores: raw-data, cache, and any other raw-* directories
```

**Restore specific artifact:**

```{r eval=FALSE}
projr_restore(label = "raw-data")
```

**Restore multiple artifacts:**

```{r eval=FALSE}
projr_restore(label = c("raw-data", "cache"))
```

**Valid labels:**

Any directory label defined in your `_projr.yml`, typically:

- `raw-data`: Source data files
- `cache`: Cached computation results
- `output`: Analysis outputs (use cautiously - usually regenerated)
- `docs`: Rendered documents (use cautiously - usually regenerated)

## Type: Which Remote Source

The `type` parameter specifies which remote type to use:

**Automatic (default):**

```{r eval=FALSE}
projr_restore()
# Uses first available: github -> osf -> local
```

**Specific remote type:**

```{r eval=FALSE}
# Restore from GitHub only
projr_restore(type = "github")

# Restore from local directory only
projr_restore(type = "local")

# Restore from OSF only
projr_restore(type = "osf")
```

**When to specify:**

- Multiple remotes configured and you want a specific one
- Testing specific remote sources
- One remote is faster or more reliable

## Title: Which Remote Configuration

The `title` parameter selects a specific remote configuration:

**Automatic (default):**

```{r eval=FALSE}
projr_restore()
# Uses first available title for selected type
```

**Specific title:**

```{r eval=FALSE}
# Use specific remote configuration
projr_restore(type = "local", title = "network-backup")
```

**Example with multiple local remotes:**

```yaml
build:
  local:
    local-backup:
      title: "local-backup"
      content: [raw-data]
      path: "~/backup/raw-data"
    network-backup:
      title: "network-backup"
      content: [raw-data]
      path: "/mnt/shared/raw-data"
```

```{r eval=FALSE}
# Restore from local backup
projr_restore(type = "local", title = "local-backup")

# Restore from network backup
projr_restore(type = "local", title = "network-backup")
```

## Pos: Source vs Destination

The `pos` parameter controls whether to restore from source directories or build destinations:

**Default (both):**

```{r eval=FALSE}
projr_restore()
# Checks "source" first, then "dest"
```

**Source only:**

```{r eval=FALSE}
projr_restore(pos = "source")
# Only restore from source directories
```

**Destination only:**

```{r eval=FALSE}
projr_restore(pos = "dest")
# Only restore from build destinations
```

**Both (explicit):**

```{r eval=FALSE}
projr_restore(pos = c("source", "dest"))
# Check both in order
```

**When to use:**

- Usually the default is appropriate
- Use `pos = "dest"` if you specifically archived outputs and want to restore them
- Use `pos = "source"` if you only want original source artifacts

---

# Complete Examples

## Example 1: New Collaborator Setup

**Scenario**: A collaborator needs to reproduce your analysis on their machine.

```{r eval=FALSE}
# Step 1: Clone repository and restore all artifacts
projr_restore_repo("satvilab/my-study")

# Step 2: Navigate into project
setwd("my-study")

# Step 3: Install R package dependencies
renv::restore()

# Step 4: Run analysis
projr_build_dev()  # Test build first
projr_build_patch()  # Production build when ready
```

## Example 2: Restore Specific Version

**Scenario**: You need to recover the exact data from version 0.1.0.

```{r eval=FALSE}
# First, check out the git tag for v0.1.0
system("git checkout v0.1.0")

# Restore artifacts for this version
projr_restore()
# projr reads manifest.csv to determine which version to restore
```

## Example 3: Selective Restoration

**Scenario**: You only need raw data, not cached results.

```{r eval=FALSE}
# Restore only raw data
projr_restore(label = "raw-data")

# Regenerate cache by running analysis
projr_build_dev()
```

## Example 4: Multiple Remote Sources

**Scenario**: You have GitHub and local remotes configured.

```{r eval=FALSE}
# Try GitHub first (default)
result <- projr_restore()

# If GitHub fails, try local explicitly
if (!result) {
  projr_restore(type = "local")
}
```

## Example 5: Network Drive Restoration

**Scenario**: Your team uses a shared network drive for data.

```yaml
# _projr.yml configuration
build:
  local:
    network-data:
      title: "network-data"
      content: [raw-data]
      path: "/mnt/shared/project-data"
```

```{r eval=FALSE}
# Restore from network drive
projr_restore(type = "local", title = "network-data")
```

---

# Authentication for Restoration

## GitHub Authentication

Restoring from GitHub requires authentication:

**Set up GitHub PAT:**

```{r eval=FALSE}
# Get instructions
projr_instr_auth_github()

# Set environment variable (add to ~/.Renviron)
# GITHUB_PAT=ghp_your_token_here
```

**Verify authentication:**

```{r eval=FALSE}
# Test that authentication works
Sys.getenv("GITHUB_PAT")  # Should show your token
```

## OSF Authentication

Restoring from OSF requires authentication:

**Set up OSF PAT:**

```{r eval=FALSE}
# Get instructions
projr_instr_auth_osf()

# Set environment variable (add to ~/.Renviron)
# OSF_PAT=your_token_here
```

## Local Directories

No authentication needed for local directories, but ensure:

- Directory paths are accessible
- You have read permissions
- Network drives are mounted (if applicable)

---

# How Restoration Works

## The Manifest System

projr uses `manifest.csv` to track file versions:

**Manifest structure:**

| label     | fn                | version | hash                             |
|-----------|-------------------|---------|----------------------------------|
| raw-data  | data/survey.csv   | v0.1.0  | 5d41402abc4b2a76b9719d911017c592 |
| raw-data  | data/survey.csv   | v0.2.0  | 5d41402abc4b2a76b9719d911017c592 |
| output    | figures/plot.png  | v0.1.0  | 098f6bcd4621d373cade4e832627b4f6 |

**How it's used in restoration:**

1. projr reads `manifest.csv` from your project
2. Finds the latest version for each file
3. Downloads files from configured remotes
4. Verifies file hashes match manifest

## Restoration Process

**Step-by-step:**

1. **Read configuration**: Parse `_projr.yml` to find remote sources
2. **Read manifest**: Load `manifest.csv` to determine file versions
3. **Select sources**: Choose appropriate remotes for each label
4. **Download files**: Retrieve files from remotes
5. **Verify integrity**: Check file hashes against manifest
6. **Extract/place files**: Put files in correct local directories

## Version Resolution

**How projr determines which version to restore:**

1. Checks current project version from `VERSION` file or `DESCRIPTION`
2. Looks for files with that version in manifest
3. Falls back to latest available version if specific version not found

**Example:**

```
Current version: v0.2.0
Manifest has: v0.1.0, v0.2.0, v0.3.0
Result: Restores v0.2.0
```

---

# Troubleshooting

## Common Issues

**"No manifest.csv found"**

- Solution: The project needs to have been built at least once with projr
- Alternative: Clone a project that has already been built

**"No remote sources configured"**

- Solution: Check `_projr.yml` has remote destinations under `build:`
- Alternative: Manually download files from GitHub releases

**"Authentication required for GitHub"**

- Solution: Set up `GITHUB_PAT` environment variable
- Run: `projr_instr_auth_github()` for instructions

**"Failed to download from remote"**

- Check internet connection
- Verify remote still exists (GitHub release, local path)
- Check authentication if required

**"File hash mismatch"**

- File on remote may be corrupted or modified
- Try restoring from different remote type
- Check if remote was updated outside of projr

## Restoration Failures

**Partial restoration:**

If some artifacts restore successfully but others fail:

```{r eval=FALSE}
# projr continues with available artifacts
# Check which failed in the output messages
```

**Recovery strategies:**

```{r eval=FALSE}
# Try different remote type
projr_restore(type = "local")  # Instead of GitHub

# Try specific artifact
projr_restore(label = "raw-data")  # One at a time

# Manual download as last resort
# Download from GitHub releases manually, then:
# Place files in appropriate directories
```

## Debugging Restoration

**Check configuration:**

```{r eval=FALSE}
# View remote configuration
projr_yml_get()$build$github
projr_yml_get()$build$local

# Validate configuration
projr_yml_check()
```

**Check manifest:**

```{r eval=FALSE}
# Read manifest to see available versions
manifest <- read.csv("manifest.csv")
manifest[manifest$label == "raw-data", ]
```

**Verbose output:**

```{r eval=FALSE}
# Set environment variable for detailed output
Sys.setenv(PROJR_OUTPUT_LEVEL = "debug")
projr_restore()
```

---

# Best Practices

## For Project Setup

**Archive raw data:**

```{r eval=FALSE}
# Configure raw data archiving (one-time setup)
projr_yml_dest_add_github(
  title = "raw-data-@version",
  content = "raw-data",
  send_cue = "if-change"
)
```

**Document restoration:**

Add to your project `README.md`:

```markdown
## Setup

1. Clone repository: `projr::projr_restore_repo("owner/repo")`
2. Restore dependencies: `renv::restore()`
3. Build project: `projr::projr_build_dev()`
```

## For Collaborators

**Share restoration instructions:**

```{r eval=FALSE}
# In project README or setup script:

# Option 1: Full automated setup
projr::projr_restore_repo("owner/repo")

# Option 2: Manual clone, then restore
# git clone https://github.com/owner/repo
# cd repo
# R
# projr::projr_restore()
```

**Test restoration process:**

```{r eval=FALSE}
# Before sharing, test in clean environment
# Create new directory, test full workflow
tempdir <- tempdir()
projr::projr_restore_repo("owner/repo", path = tempdir)
```

## For Version Control

**Archive at meaningful milestones:**

```{r eval=FALSE}
# After major analysis completion
projr_build_minor()  # Bumps version, archives artifacts

# After data updates
projr_build_patch()  # Bumps patch, archives if changed
```

**Document version history:**

Keep notes on what changed in each version:

```markdown
## Version History

- v0.3.0: Updated analysis with new data from 2024
- v0.2.0: Added sensitivity analyses
- v0.1.0: Initial analysis with 2023 data
```

## For Reproducibility

**Archive everything needed:**

```{r eval=FALSE}
# Archive code (all Git-tracked files)
projr_yml_dest_add_github(
  title = "code-@version",
  content = "code"
)

# Archive raw data
projr_yml_dest_add_github(
  title = "raw-data-@version",
  content = "raw-data"
)

# Archive outputs for comparison
projr_yml_dest_add_github(
  title = "output-@version",
  content = "output"
)
```

**Document dependencies:**

```{r eval=FALSE}
# Use renv for R package versions
renv::snapshot()

# Document system dependencies in README
# - R version 4.3.0
# - System libraries: libcurl, libxml2
```

---

# Advanced Topics

## Restoring from Specific Versions

**Checkout specific Git version:**

```{r eval=FALSE}
# View available versions
system("git tag")

# Checkout specific version
system("git checkout v0.2.0")

# Restore artifacts for this version
projr_restore()
```

## Custom Restoration Workflows

**Restore only if needed:**

```{r eval=FALSE}
# Check if raw data exists
if (!dir.exists("_raw_data") || length(list.files("_raw_data")) == 0) {
  message("Restoring raw data...")
  projr_restore(label = "raw-data")
} else {
  message("Raw data already present, skipping restoration.")
}
```

**Restore with error handling:**

```{r eval=FALSE}
# Try multiple sources
restore_with_fallback <- function() {
  # Try GitHub first
  result <- tryCatch(
    projr_restore(type = "github"),
    error = function(e) {
      message("GitHub restoration failed: ", e$message)
      FALSE
    }
  )
  
  # Fall back to local
  if (!result) {
    message("Trying local restoration...")
    projr_restore(type = "local")
  }
}

restore_with_fallback()
```

## Restoration in CI/CD

**GitHub Actions example:**

```yaml
# .github/workflows/analysis.yml
name: Run Analysis
on: [push]

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Setup R
        uses: r-lib/actions/setup-r@v2
      
      - name: Restore artifacts
        env:
          GITHUB_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Rscript -e "projr::projr_restore()"
      
      - name: Build project
        run: |
          Rscript -e "projr::projr_build_dev()"
```

---

# Summary

**Key Concepts:**

- **Artifacts**: Versioned project components (raw-data, output, etc.)
- **Manifest**: CSV file tracking file versions and hashes
- **Remotes**: Sources from which artifacts can be restored
- **Restoration**: Downloading and placing artifacts from remotes

**Main Functions:**

```{r eval=FALSE}
# Clone repository and restore artifacts
projr_restore_repo("owner/repo")

# Restore in existing project
projr_restore()

# Restore specific artifacts
projr_restore(label = "raw-data")

# Restore from specific remote
projr_restore(type = "github", title = "raw-data-release")
```

**Quick Start:**

```{r eval=FALSE}
# New machine setup (most common)
projr_restore_repo("owner/repo")
setwd("repo")
renv::restore()

# Restore in existing project
projr_restore()

# Restore specific artifact
projr_restore(label = "raw-data")
```

**Troubleshooting Checklist:**

1. Check `manifest.csv` exists in project root
2. Verify `_projr.yml` has remote configurations
3. Ensure authentication is set up (GitHub PAT, OSF PAT)
4. Check internet connection
5. Verify remote sources still exist
6. Try different remote type or title

**See Also:**

- `?projr_restore` - Restoration function documentation
- `?projr_restore_repo` - Repository restoration documentation
- `vignette("send-to-remotes")` - Configuring remotes for archiving
- `vignette("concepts")` - Core projr concepts
- `vignette("how-to-guides")` - Task-focused guides
